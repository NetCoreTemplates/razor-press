# What is Razor Press?
Source: https://razor-press.web-templates.io/what-is-razor-press

Razor Press is a Razor Pages powered Markdown alternative to Ruby's Jekyll, Vue & VitePress that's ideal for 
generating fast, static content-centric & documentation websites. Inspired by [VitePress](https://vitepress.dev), 
it's designed to effortlessly create documentation around content written in Markdown, rendered using C# Razor Pages
and beautifully styled with [tailwindcss](https://tailwindcss.com) and [@tailwindcss/typography](https://tailwindcss.com/docs/typography-plugin).

The resulting statically generated HTML pages can easily be deployed anywhere, where it can be hosted by any HTTP Server or CDN.
By default it includes GitHub Actions to deploy it your GitHub Repo's **gh-pages** branch where it's hosted for FREE
on [GitHub Pages](https://pages.github.com) CDN which can be easily configured to use your 
[Custom Domain](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site).

## Use Cases

Razor Press utilizes the same technology as 
[Razor SSG](https://razor-ssg.web-templates.io/posts/razor-ssg) which is the template we recommend for developing any
statically generated sites with Razor like Blogs, Portfolios, and Marketing Sites as it includes more Razor & Markdown 
features like blogs and integration with [Creator Kit](https://servicestack.net/creatorkit/) - a companion OSS project
offers the necessary tools any static website can use to reach and retain users, from managing subscriber mailing lists to 
moderating a feature-rich comments system.

Some examples built with Razor SSG include:

<div class="not-prose mt-8 grid grid-cols-2 gap-4">
    <a class="block group border dark:border-gray-800 hover:border-indigo-700 dark:hover:border-indigo-700 flex flex-col justify-between" href="https://servicestack.net">
        <img class="p-2" src="https://docs.servicestack.net/img/pages/ssg/servicestack.net-home-1440.png">
        <div class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-300 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">servicestack.net</div>
    </a>
    <a class="block group border dark:border-gray-800 hover:border-indigo-700 dark:hover:border-indigo-700" href="https://diffusion.works">
        <div style="max-height:350px;overflow:hidden">
        <img class="p-2" src="https://servicestack.net/img/posts/vue-diffusion/vuediffusion-search.png"></div>
        <div class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-300 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">diffusion.works</div>
    </a>
    <a class="block group border dark:border-gray-800 hover:border-indigo-700 dark:hover:border-indigo-700" href="https://jamstacks.net">
        <img class="p-2" src="https://docs.servicestack.net/img/pages/release-notes/v6.9/jamstacks-screenshot.png">
        <div class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-300 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">jamstacks.net</div>
    </a>
    <a class="block group border dark:border-gray-800 hover:border-indigo-700 dark:hover:border-indigo-700" href="https://xkcd.netcore.io">
        <img class="p-2" src="https://docs.servicestack.net/img/pages/release-notes/v6.9/xkcd-screenshot.png">
        <div class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-300 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">xkcd.netcore.io</div>
    </a>
</div>

## Documentation

Razor Press is instead optimized for creating documentation and content-centric websites, with built-in features useful
for documentation websites including:

 - Customizable Sidebar Menus
 - Document Maps
 - Document Page Navigation
 - Autolink Headers
 
#### Markdown Extensions
 
- Markdown Content Includes
- Tip, Info, Warning, Danger sections
- Copy and Shell command widgets

But given **Razor Press** and **Razor SSG** share the same implementation, their features are easily transferable, e.g.
The [What's New](/whatsnew) and [Videos](/videos) sections are 
[features copied](https://razor-ssg.web-templates.io/posts/razor-ssg#whats-new-feature) from Razor SSG as they can be
useful in Documentation websites.

## Customizable {#custom-anchor .custom}

The source code of all Markdown and Razor Pages features are included in the template with all Markdown extensions
implemented in the [Markdown*.cs](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp) files allowing for
easier inspection, debugging and customization.

To simplify updating Markdown features in future we recommend against modifying the included `Markdown.*` files and instead
add any Markdig pipeline extensions or custom containers using `MarkdigConfig` in `Configure.Ssg.cs`: 

```csharp
MarkdigConfig.Set(new MarkdigConfig
{
    ConfigurePipeline = pipeline =>
    {
        // Extend Markdig Pipeline
    },
    ConfigureContainers = config =>
    {
        config.AddBuiltInContainers();
        // Add Custom Block or Inline containers
    }
});
```

### Update Markdown Extensions & Dependencies

Updating to the latest JavaScript dependencies and Markdown extensions can be done by running:

:::sh
npm install
:::

Which as the template has no npm dependencies, is just an alias for running `node postinstall.js`

## Example

The largest website generated with Razor Press is currently the ServiceStack's documentation at 
[docs.servicestack.net](https://docs.servicestack.net):

<div class="not-prose mt-8 grid grid-cols-2 gap-4">
    <a class="block group border dark:border-gray-800 hover:border-indigo-700 dark:hover:border-indigo-700" href="https://docs.servicestack.net/?light">
        <img class="p-2" src="https://servicestack.net/img/posts/razor-ssg/docs.servicestack.net.png">
        <div class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-300 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">docs.servicestack.net</div>
    </a>
    <a class="block group border dark:border-gray-800 hover:border-indigo-700 dark:hover:border-indigo-700" href="https://docs.servicestack.net/?dark">
        <img class="p-2" src="https://servicestack.net/img/posts/razor-ssg/docs.servicestack.net-dark.png">
        <div class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-300 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">docs.servicestack.net</div>
    </a>
</div>

A **500+** pages documentation website ported from VitePress, which prompted the creation of Razor Press after
experiencing issues with VitePress's SSR/SPA model whose workaround became too time consuming to maintain.

The new Razor SSG implementation now benefits from Razor Pages flexible layouts and partials where pages can be optionally
implemented in just markdown, Razor or a hybrid mix of both. The [Vue](/vue/) splash page is an example of this implemented in a custom
[/Vue/Index.cshtml](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Pages/Vue/Index.cshtml) Razor Page.

<div class="not-prose mt-8 grid grid-cols-2 gap-4">
    <a class="block group border dark:border-gray-800 hover:border-indigo-700 dark:hover:border-indigo-700" href="/vue/">
        <img class="p-2" src="https://docs.servicestack.net/img/pages/ssg/razor-pages-vue.png">
        <div class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-300 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">docs.servicestack.net</div>
    </a>
</div>

## Feedback & Feature Requests Welcome

Up to this stage [docs.servicestack.net](https://docs.servicestack.net) has been the primary driver for Razor Press 
current feature-set, re-implementing all the previous VitePress features it used with C#, Razor Pages and Markdig extensions. 

In future we'll look at expanding this template with generic Markdown features suitable for documentation or content-centric 
websites, for which we welcome any feedback or new feature requests at:

<div class="not-prose">
   <h3 class="m-0 py-8 text-3xl text-center text-blue-600"><a href="https://servicestack.net/ideas">https://servicestack.net/ideas</a></h3>
</div>


# Structure
Source: https://razor-press.web-templates.io/structure

### Markdown Feature Structure

All markdown features are effectively implemented in the same way, starting with a **_folder** for maintaining its static markdown
content, a **.cs** class to load the markdown and a **.cshtml** Razor Page to render it:

| Location                                                                                             | Description                                                           |
|------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------|
| `/_{Feature}`                                                                                        | Maintains the static markdown for the feature                         |
| `Markdown.{Feature}.cs`                                                                              | Functionality to read the feature's markdown into logical collections |
| `{Feature}.cshtml`                                                                                   | Functionality to Render the feature                                   |
| [Configure.Ssg.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Configure.Ssg.cs) | Initializes and registers the feature with ASP .NET's IOC             |

Lets see what this looks like in practice by walking through the "Pages" feature:

## Pages Feature

The pages feature simply makes all pages in the **_pages** folder, available from `/{filename}`.

Where the included pages:

```files
/_pages
  what-is-razor-press.md
  structure.md
  privacy.md    
```

Are made available from:

- [/what-is-razor-press](/what-is-razor-press)
- [/structure](/structure)
- [/privacy](/privacy)

This is primarily where most Markdown documentation will be maintained. 

### Document Collections

Folders can be used to maintain different document collections as seen in [/vue/](/vue/) and [/creatorkit/](/creatorkit/) folders: 

```files
/_pages
  /creatorkit
    about.md
    components.md
    customize.md
  /vue
    alerts.md
    autocomplete.md
    autoform.md
```

Each documentation collection needs a Razor Page to render each page in that collection, which can be configured independently
and include additional features when needed, examples of this include:

- [/Vue/Page.cshtml](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp/Pages/Vue/Page.cshtml)
- [/CreatorKit/Page.cshtml](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp/Pages/CreatorKit/Page.cshtml)

They can contain custom Razor Pages as needed, e.g. both [/vue/](/and/) and [/creatorkit/](/creatorkit/) have custom index pages:

- [/Vue/Index.cshtml](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp/Pages/Vue/Index.cshtml)
- [/CreatorKit/Index.cshtml](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp/Pages/CreatorKit/Index.cshtml)

If no custom home page is needed, a `/{slug?}` or `/{**slug}` wildcard route can be used to handle a collection's 
index and content pages, e.g:

- [/AutoQuery.cshtml](https://github.com/ServiceStack/docs.servicestack.net/blob/main/MyApp/Pages/AutoQuery.cshtml)
- [/OrmLite.cshtml](https://github.com/ServiceStack/docs.servicestack.net/blob/main/MyApp/Pages/OrmLite.cshtml)
- [/Redis.cshtml](https://github.com/ServiceStack/docs.servicestack.net/blob/main/MyApp/Pages/Redis.cshtml)

Which are used to render all pages in each documentation collection:

- [docs.servicestack.net/autoquery/](https://docs.servicestack.net/autoquery/)
- [docs.servicestack.net/ormlite/](https://docs.servicestack.net/ormlite/)
- [docs.servicestack.net/redis/](https://docs.servicestack.net/redis/)

::: tip
See [Sidebars](/sidebars) for how to configure different Sidebar menus for each collection
:::

### Loading Markdown Pages

The code that loads the Pages feature markdown content is in [Markdown.Pages.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Markdown.Pages.cs),
which ultimately just loads Markdown files using the configured [Markdig](https://github.com/xoofx/markdig) pipeline that 
is made available via its `VisiblePages` property which returns all documents **during development** but hides any
**Draft** or content published at a **Future Date** from **production builds**.

## What's New Feature

The [/whatsnew](/whatsnew) page is an example of creating a custom Markdown feature to implement a portfolio or a product releases page
where a new folder is created per release, containing both release date and release or project name, with all features in that release
maintained markdown content sorted in alphabetical order:

```files
/_whatsnew
  /2023-03-08_Animaginary
    feature1.md
  /2023-03-18_OpenShuttle
    feature1.md
  /2023-03-28_Planetaria
    feature1.md    
```

What's New follows the same structure as Pages feature which is loaded in:

- [Markdown.WhatsNew.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Markdown.WhatsNew.cs)

and rendered in:
- [WhatsNew.cshtml](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Pages/WhatsNew.cshtml)

## Markdown Videos Feature

Videos is another Markdown powered feature for display collections of YouTube videos populated from a Directory of Markdown Video
pages in [/_videos](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp/_videos):

```files
/_videos
  /projects
    video1.md
    video2.md
  /vue
    video1.md
    video2.md
```

Loaded with:
 
- [Markdown.Videos.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Markdown.Videos.cs)

and Rendered with Razor Pages:

- [Shared/VideoGroup.cshtml](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Pages/Shared/VideoGroup.cshtml) - Razor Partial for displaying a Video Collection
- [Videos.cshtml](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Pages/Videos.cshtml) - Razor Page displaying multiple Video Collections

## Metadata APIs Feature

Typically a disadvantage of statically generated websites is the lack of having APIs we can call to query website data 
in a easily readable data format like JSON. However we can also easily support this by also pre-rendering static `*.json` 
data structures along with the pre-rendered website at deployment.

This capability is provided by the new [Markdown.Meta.cs](https://github.com/NetCoreTemplates/razor-ssg/blob/main/MyApp/Markdown.Meta.cs) 
feature which generates multiple projections of the Markdown metadata for each type of content added in every year, e.g:

```files
/meta
  /2021
    all.json
    posts.json
    videos.json
  /2022
    all.json
    posts.json
  /2023
    all.json
    pages.json
    posts.json
    videos.json
    whatsnew.json
  all.json
  index.json    
```

With this you can fetch the metadata of all the new **Blog Posts** added in **2023** from:

[/2023/posts.json](https://razor-ssg.web-templates.io/meta/2023/posts.json)

Or all the website content added in **2023** from:

[/2023/all.json](https://razor-ssg.web-templates.io/meta/2023/all.json)

Or **ALL** the website metadata content from:

[/all.json](https://razor-ssg.web-templates.io/meta/all.json)

This feature makes it possible to support use-cases like CreatorKit's
[Generating Newsletters](https://servicestack.net/creatorkit/portal-mailruns#generating-newsletters) feature which generates 
a Monthly Newsletter Email with all new content added within a specified period.

## General Features

Most unique markdown features are captured in their Markdown's frontmatter metadata, but in general these features
are broadly available for all features:

- **Live Reload** - Latest Markdown content is displayed during **Development**
- **Custom Layouts** - Render post in custom Razor Layout with `layout: _LayoutAlt`
- **Drafts** - Prevent posts being worked on from being published with `draft: true`
- **Future Dates** - Posts with a future date wont be published until that date
- **Order** - Specify custom ordering for a collection pages

### Initializing and Loading Markdown Features

All markdown features are initialized in the same way in [Configure.Ssg.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Configure.Ssg.cs)
where they're registered in ASP.NET Core's IOC and initialized after the App's plugins are loaded
by injecting with the App's [Virtual Files provider](https://docs.servicestack.net/virtual-file-system)
before using it to read from the directory where the markdown content for each feature is maintained:

```csharp
public class ConfigureSsg : IHostingStartup
{
    public void Configure(IWebHostBuilder builder) => builder
        .ConfigureServices(services =>
        {
            context.Configuration.GetSection(nameof(AppConfig)).Bind(AppConfig.Instance);
            services.AddSingleton(AppConfig.Instance);
            services.AddSingleton<RazorPagesEngine>();
            services.AddSingleton<MarkdownPages>();
            services.AddSingleton<MarkdownWhatsNew>();
            services.AddSingleton<MarkdownVideos>();
            services.AddSingleton<MarkdownMeta>();
        })
        .ConfigureAppHost(afterPluginsLoaded: appHost => {
            MarkdigConfig.Set(new MarkdigConfig
            {
                ConfigurePipeline = pipeline =>
                {
                    // Extend Markdig Pipeline
                },
                ConfigureContainers = config =>
                {
                    config.AddBuiltInContainers();
                    // Add Custom Block or Inline containers
                }
            });

            var pages = appHost.Resolve<MarkdownPages>();
            var whatsNew = appHost.Resolve<MarkdownWhatsNew>();
            var videos = appHost.Resolve<MarkdownVideos>();
            var meta = appHost.Resolve<MarkdownMeta>();

            meta.Features = new() { pages, whatsNew, videos };
            meta.Features.ForEach(x => x.VirtualFiles = appHost.VirtualFiles);
            
            pages.LoadFrom("_pages");
            whatsNew.LoadFrom("_whatsnew");
            videos.LoadFrom("_videos");
        });
    });
    //...
}
```

These dependencies are then injected in the feature's Razor Pages to query and render the loaded markdown content.

## Custom Frontmatter

You can extend the `MarkdownFileInfo` type used to maintain the markdown content and metadata of each loaded Markdown file
by adding any additional metadata you want included as C# properties on:

```csharp
// Add additional frontmatter info to include
public class MarkdownFileInfo : MarkdownFileBase
{
}
```

Any additional properties are automatically populated using ServiceStack's
[built-in Automapping](https://docs.servicestack.net/auto-mapping) which includes rich support for converting string frontmatter
values into native .NET types.

## Updating to latest version

You can easily update all the JavaScript dependencies used in
[postinstall.js](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/postinstall.js) by running:

:::sh
npm install
:::

This will also update the Markdown features `*.cs` implementations which is delivered as source files instead of an external
NuGet package to enable full customization, easier debugging whilst supporting easy upgrades.

If you do customize any `Markdown*.cs` files, you'll want to exclude them from being updated by removing them from:

```js
const hostFiles = [
  'Markdown.Meta.cs',
  'Markdown.Pages.cs',
  'Markdown.WhatsNew.cs',
  'Markdown.Videos.cs',
  'MarkdownPagesBase.cs',
  'MarkdownTagHelper.cs',
]
```

## Markdown Tag Helper

The included [MarkdownTagHelper.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/MarkdownTagHelper.cs) can be used
in hybrid Razor Pages like [About.cshtml](https://github.com/NetCoreTemplates/razor-ssg/blob/main/MyApp/Pages/About.cshtml)
to render the [/about](/about) page which uses the flexibility of Razor Pages and static content component maintained with inline Markdown.

The `<markdown />` tag helper renders plain HTML, which you can apply [Tailwind's @typography](https://tailwindcss.com/docs/typography-plugin)
styles by including **typography.css** and annotating it with your preferred `prose` variant, e.g:

```html
<link rel="stylesheet" href="/css/typography.css">
<markdown class="prose">
  Markdown content...
</markdown>
```


# Static Site Generation (SSG)
Source: https://razor-press.web-templates.io/ssg

All features up till now describes how this template implements a Markdown powered Razor Pages .NET application, where this template
differs in its published output, where instead of a .NET App deployed to a VM or App server it generates static `*.html` files that's
bundled together with `/wwwroot` static assets in the `/dist` folder with:

:::sh
npm run prerender
:::

That can then be previewed by launching a HTTP Server from the `/dist` folder with the built-in npm script:

:::sh
npm run serve
:::

That runs **npx http-server** on `http://localhost:8080` that you can open in a browser to preview the published version of your
site as it would be when hosted on a CDN.

### Static Razor Pages

The static generation functionality works by scanning all your Razor Pages and prerendering the pages with prerendering instructions.

### Pages with Static Routes

Pages with static routes can be marked to be prerendered by annotating it with the `[RenderStatic]` attribute as done in
[About.cshtml](https://github.com/NetCoreTemplates/razor-ssg/blob/main/MyApp/Pages/About.cshtml):

```csharp
@page "/about"
@attribute [RenderStatic]
```

Which saves the pre-rendered page using the pages route with a **.html** suffix, e.g: `/{@page route}.html` whilst pages with static
routes with a trailing `/` are saved to `/{@page route}/index.html`:

```csharp
@page "/vue/"
@attribute [RenderStatic]
```

#### Explicit generated paths

To keep the generated pages in-sync with using the same routes as your Razor Pages in development it's recommended to use the implied
rendered paths, but if preferred you can specify which path the page should render to instead with:

```csharp
@page "/vue/"
@attribute [RenderStatic("/vue/index.html")]
```

### Pages with Dynamic Routes

Prerendering dynamic pages follows [Next.js getStaticProps](https://nextjs.org/docs/basic-features/data-fetching/get-static-props)
convention which you can implement using `IRenderStatic<PageModel>` by returning a Page Model for each page that should be generated
as done in [Vue/Page.cshtml](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Pages/Vue/Page.cshtml) and
[Page.cshtml](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Pages/Page.cshtml):

```csharp
@page "/{slug}"
@model MyApp.Page

@implements IRenderStatic<MyApp.Page>
@functions {
    public List<Page> GetStaticProps(RenderContext ctx)
    {
        var markdown = ctx.Resolve<MarkdownPages>();
        return markdown.GetVisiblePages().Map(page => new Page { Slug = page.Slug! });
    }
}
...
```

In this case it returns a Page Model for every **Visible** markdown page in
[/_pages](https://github.com/NetCoreTemplates/razor-ssg/tree/main/MyApp/_pages) that ends up rendering the following pages in `/dist`:

- `/what-is-razor-press.html`
- `/structure.html`
- `/privacy.html`

### Limitations

The primary limitations for developing statically generated Apps is that a **snapshot** of entire App is generated at deployment,
which prohibits being able to render different content **per request**, e.g. for Authenticated users which would instead require 
executing custom JavaScript after the page loads to dynamically alter the page's initial content.

Otherwise in practice you'll be able develop your Razor Pages utilizing Razor's full feature-set, the primary concessions stem
from Pages being executed in a static context which prohibits pages from returning dynamic content per request, instead any
**"different views"** should be maintained in separate pages.

#### No QueryString Params

As the generated pages should adopt the same routes as your Razor Pages you'll need to avoid relying on **?QueryString** params
and instead capture all required parameters for a page in its **@page route** as done for:

[Posts/Author.cshtml](https://github.com/NetCoreTemplates/razor-ssg/blob/main/MyApp/Pages/Posts/Author.cshtml)

```csharp
@page "/posts/author/{slug}"
@model AuthorModel
@inject MarkdownBlog Blog

@implements IRenderStatic<AuthorModel>
@functions {
    public List<AuthorModel> GetStaticProps(RenderContext ctx) => ctx.Resolve<MarkdownBlog>()
        .AuthorSlugMap.Keys.Map(x => new AuthorModel { Slug = x });
}
...
```

Which lists all posts by an Author, e.g: [/posts/author/lucy-bates](https://razor-ssg.web-templates.io/posts/author/lucy-bates), 
likewise required for:

[Posts/Tagged.cshtml](https://github.com/NetCoreTemplates/razor-ssg/blob/main/MyApp/Pages/Posts/Tagged.cshtml)

```csharp
@page "/posts/tagged/{slug}"
@model TaggedModel
@inject MarkdownBlog Blog

@implements IRenderStatic<TaggedModel>
@functions {
    public List<TaggedModel> GetStaticProps(RenderContext ctx) => ctx.Resolve<MarkdownBlog>()
        .TagSlugMap.Keys.Map(x => new TaggedModel { Slug = x });
}
...
```

Which lists all related posts with a specific tag, e.g: 
[/posts/tagged/markdown](https://razor-ssg.web-templates.io/posts/tagged/markdown), and for:

[Posts/Year.cshtml](https://github.com/NetCoreTemplates/razor-ssg/blob/main/MyApp/Pages/Posts/Year.cshtml)

```csharp
@page "/posts/year/{year}"
@model YearModel
@inject MarkdownBlog Blog

@implements IRenderStatic<YearModel>
@functions {
    public List<YearModel> GetStaticProps(RenderContext ctx) => ctx.Resolve<MarkdownBlog>()
        .VisiblePosts.Select(x => x.Date.GetValueOrDefault().Year)
            .Distinct().Map(x => new YearModel { Year = x });
}

...
```

Which lists all posts published in a specific year, e.g: 
[/posts/year/2023](https://razor-ssg.web-templates.io/posts/year/2023).

Conceivably these "different views" could've been implemented by the same page with different `?author`, `?tag` and `?year`
QueryString params, but need to instead be extracted into different pages to support its statically generated `*.html` outputs.

## Prerendering Task

The **prerender** [AppTask](https://docs.servicestack.net/app-tasks) that pre-renders the entire website is also registered in
[Configure.Ssg.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Configure.Ssg.cs):

```csharp
.ConfigureAppHost(afterAppHostInit: appHost =>
{
    // prerender with: `$ npm run prerender` 
    AppTasks.Register("prerender", args =>
    {
        appHost.Resolve<MarkdownMeta>().RenderToAsync(
            metaDir: appHost.ContentRootDirectory.RealPath.CombineWith("wwwroot/meta"),
            baseUrl: HtmlHelpers.ToAbsoluteContentUrl("")).GetAwaiter().GetResult();
        
        var distDir = appHost.ContentRootDirectory.RealPath.CombineWith("dist");
        if (Directory.Exists(distDir))
            FileSystemVirtualFiles.DeleteDirectory(distDir);
        FileSystemVirtualFiles.CopyAll(
            new DirectoryInfo(appHost.ContentRootDirectory.RealPath.CombineWith("wwwroot")),
            new DirectoryInfo(distDir));
        
        // Render .html redirect files
        RazorSsg.PrerenderRedirectsAsync(appHost.ContentRootDirectory.GetFile("redirects.json"), distDir)
            .GetAwaiter().GetResult();
        
        var razorFiles = appHost.VirtualFiles.GetAllMatchingFiles("*.cshtml");
        RazorSsg.PrerenderAsync(appHost, razorFiles, distDir).GetAwaiter().GetResult();
    });
});
//...
```

Which we can see:
1. Deletes `/dist` folder
2. Copies `/wwwroot` contents into `/dist`
3. [Generates redirect](/redirects) `.html` files for all paths in `redirects.json`
4. Passes all App's Razor `*.cshtml` files to `RazorSsg` to do the pre-rendering

Where it processes all pages with `[RenderStatic]` and `IRenderStatic<PageModel>` prerendering instructions to the
specified `/dist` folder.

### Previewing prerendered site

To preview your SSG website, run the prerendered task with:

:::sh
npm run prerender
:::

Which renders your site to `/dist` which you can run a HTTP Server from with:

:::sh
npm run serve
:::

That you can preview with your browser at `http://localhost:8080`.


# Deployments
Source: https://razor-press.web-templates.io/deployments

## Enable GitHub Pages

The included [build.yml](https://github.com/NetCoreTemplates/razor-ssg/blob/main/.github/workflows/build.yml) GitHub Action
takes care of running the prerendered task and deploying it to your Repo's GitHub Pages where you'll need to enable 
GitHub Pages to be hosted from your **gh-pages** branch in your Repository settings:

![](/img/posts/razor-ssg/gh-pages.png)

## Register Custom Domains

You should then register a [Custom domain for GitHub Pages](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages)
by registering a `CNAME` DNS entry for your preferred Custom Domain, e.g:

| Record | Type | Value | TTL|
| - | - | - | - |
| **mydomain.org** | CNAME | **org_name**.github.io | 3600 |

That you can either [configure in your Repo settings](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-a-subdomain)
or if you prefer to maintain it with your code-base, save the domain name to `/wwwroot/CNAME`, e.g:

```
www.mydomain.org
```


# Markdown Syntax
Source: https://razor-press.web-templates.io/syntax

## Configuring Markdig

Razor Press uses the high-quality [Markdig](https://github.com/xoofx/markdig) CommonMark compliant implementation 
for its Markdown parsing in .NET.

Each [Markdown*.cs](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp) feature is able to customize
which [Markdig features](https://github.com/xoofx/markdig#features) it wants to use by providing a custom
`CreatePipeline()` implementation with all the Markdig extensions it needs.

Alternatively the Markdig pipeline can be globally extended for all Markdown features by adding it to `MarkdigConfig` 
pipeline in [Configure.Ssg.cs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Configure.Ssg.cs):

```csharp
MarkdigConfig.Set(new MarkdigConfig
{
    ConfigurePipeline = pipeline =>
    {
        // Extend Markdig Pipeline
    },
    ConfigureContainers = config =>
    {
        config.AddBuiltInContainers();
        // Add Custom Block or Inline containers
    }
});
```

## Header Anchors

Headers, like above, automatically get anchor links applied with an **id** that's automatically generated from the 
Header text.

### Custom Anchors {#my-anchor}

To specify a custom anchor tag for a heading instead of using the auto-generated one, add a suffix to the heading:

```markdown
### Custom Anchors {#my-anchor}
```

This allows you to link to the heading as `#my-anchor` instead of the default `#custom-anchors`.

### Custom Classes 

Custom Classes can be added to headings with the suffix:

```markdown
### Custom Classes {.my-class}
### Custom Classes {#my-anchor .my-class .my-class2}
```

However to override the default [@tailwindcss/typography](https://tailwindcss.com/docs/typography-plugin) styles applied
to headings they'll need to included within a `not-prose` class which can be done with:

```markdown
:::{.not-prose}
## Custom Class {.text-5xl .font-extrabold .tracking-tight .text-indigo-600}
:::
```

Which generates the HTML:

```html
<div class="not-prose">
    <h2 id="custom-class" class="text-5xl font-extrabold tracking-tight text-indigo-600">
        Custom Class
    </h2>
</div>
```

To render it with the custom tailwind styles we want:

:::{.not-prose}
## Custom Class {.text-5xl .font-extrabold .tracking-tight .text-indigo-600}
:::

## Document Map

A Document Map is created for each Markdown document from its **Heading 2** and **Heading 3** headings, e.g: 

```markdown
## Heading 2
### Heading 3
### Heading 3a

## Heading 2a
```

Which populates the `MarkdownFileInfo.DocumentMap` collection that renders the Document Map on the right column of
each document, that's displayed in devices with larger resolutions that can fit them.

The document map also makes use of the Auto heading anchors for its navigation, that's kept updated as you scroll.

## GitHub-Style Tables

Many [GitHub Flavored Markdown](https://github.github.com/gfm/) syntax is also supported in Markdig like their ASCII
[Tables](https://github.github.com/gfm/#tables-extension-), e.g:

#### Input

```markdown
| Tables        |      Are      |  Cool |
| ------------- | :-----------: | ----: |
| col 3 is      | right-aligned | $1600 |
| col 2 is      |   centered    |   $12 |
| zebra stripes |   are neat    |    $1 |
```

#### Output

| Tables        |      Are      |  Cool |
| ------------- | :-----------: | ----: |
| col 3 is      | right-aligned | $1600 |
| col 2 is      |   centered    |   $12 |
| zebra stripes |   are neat    |    $1 |

Which can be further styled with custom classes:

#### Input

```markdown
:::{.not-prose .table .table-striped}
| Tables        |      Are      |  Cool |
| ------------- | :-----------: | ----: |
| col 3 is      | right-aligned | $1600 |
| col 2 is      |   centered    |   $12 |
| zebra stripes |   are neat    |    $1 |
:::
```

#### Output

:::{.not-prose .table .table-striped}
| Tables        |      Are      |  Cool |
| ------------- | :-----------: | ----: |
| col 3 is      | right-aligned | $1600 |
| col 2 is      |   centered    |   $12 |
| zebra stripes |   are neat    |    $1 |
:::

## Syntax Highlighting in Code Blocks

Razor Press uses [highlight.js](https://highlightjs.org) to highlight code blocks allowing you to add syntax highlighting 
using the same syntax as 
[GitHub Code Blocks](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks), e.g:

#### Input

:::pre
```csharp
class A<T>
{
    public string? B { get; set; }
}
```
:::

#### Output

```csharp
class A<T>
{
    public string? B { get; set; }
}
```

#### Input

:::pre
```json
{ "A": 1, "B": true }
```
:::

#### Output

```json
{ "A": 1, "B": true }
```

## Markdown Fragments

Markdown fragments should be maintained in `_pages/_include` - a special folder rendered with
[Pages/Includes.cshtml](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/Pages/Includes.cshtml) using
an Empty Layout which can be included in other Markdown and Razor Pages or fetched on demand with Ajax
from [/includes/vue/formatters](/includes/vue/formatters).

## Includes

Markdown Fragments can be included inside other markdown documents with the `::include` inline container, e.g:

:::pre
::include vue/formatters.md::
:::

Where it will be replaced with the HTML rendered markdown contents of markdown fragments maintained in `_pages/_include`, 
which in this case embeds the rendered contents of [_include/vue/formatters.md](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/_include/vue/formatters.md).

### Include Markdown in Razor Pages

Markdown Fragments can be included in Razor Pages using the custom `MarkdownTagHelper.cs` `<markdown/>` tag: 

```html
<markdown include="vue/formatters.md"></markdown>
```

### Inline Markdown in Razor Pages

Alternatively markdown can be rendered inline with:

```html
<markdown>
## Using Formatters

Your App and custom templates can also utilize @servicestack/vue's
[built-in formatting functions](href="/vue/use-formatters).
</markdown>
```


# Custom Markdown Containers
Source: https://razor-press.web-templates.io/containers

[Custom Containers](https://github.com/xoofx/markdig/blob/master/src/Markdig.Tests/Specs/CustomContainerSpecs.md) are a 
popular method for implementing Markdown Extensions for enabling rich, wrist-friendly consistent content in your Markdown documents. 

## Built-in Containers

Most of [VitePress Containers](https://vitepress.dev/guide/markdown#custom-containers) are also implemented in Razor Press, e.g:

#### Input

```markdown
::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::
```

#### Output

::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

### Custom Title

You can specify a custom title by appending the text right after the container type:

#### Input

```markdown
::: danger STOP
Danger zone, do not proceed
:::
```

#### Output

::: danger STOP
Danger zone, do not proceed
:::

### Pre

The **pre** container can be used to capture its content in a `<pre>` element instead of it's default markdown rendering:

```markdown
:::pre
...
:::
```

### copy

The **copy** container is ideal for displaying text snippets in a component that allows for easy copying:

#### Input

```markdown
:::copy
Copy Me!
:::
```

#### Output

:::copy
Copy Me!
:::

HTML or XML fragments can also be copied by escaping them first:

#### Input

```markdown
:::copy
`<PackageReference Include="ServiceStack" Version="6.*" />`
:::
```

#### Output

:::copy
`<PackageReference Include="ServiceStack" Version="6.*" />`
:::

### sh

Similarly the **sh** container is ideal for displaying and copying shell commands:

#### Input

```markdown
:::sh
npm run prerender
:::
```

#### Output

:::sh
npm run prerender
:::

## Implementing Block Containers

[Markdig Containers](https://github.com/xoofx/markdig/blob/master/src/Markdig.Tests/Specs/CustomContainerSpecs.md) are a
great way to create rich widgets that can be used directly in Markdown. 

They're useful for ensuring similar content is displayed consistently across all your documentation. A good use-case for
this could be to implement a YouTube component for standardizing how YouTube videos are displayed.

For this example we want to display a YouTube video using just its YouTube **id** and a **title** for the video which we can
capture in the Custom Container: 

```markdown
:::YouTube MRQMBrXi5Sc
Using Razor SSG to Create Websites in GitHub Codespaces
:::
```

Which we can implement with a normal Markdig `HtmlObjectRenderer<CustomContainer>`:

```csharp
public class YouTubeContainer : HtmlObjectRenderer<CustomContainer>
{
    protected override void Write(HtmlRenderer renderer, CustomContainer obj)
    {
        if (obj.Arguments == null)
        {
            renderer.WriteLine($"Missing YouTube Id, Usage :::{obj.Info} <id>");
            return;
        }
        
        renderer.EnsureLine();

        var youtubeId = obj.Arguments!;
        var attrs = obj.TryGetAttributes()!;
        attrs.Classes ??= new();
        attrs.Classes.Add("not-prose text-center");
        
        renderer.Write("<div").WriteAttributes(obj).Write('>');
        renderer.WriteLine("<div class=\"text-3xl font-extrabold tracking-tight\">");
        renderer.WriteChildren(obj);
        renderer.WriteLine("</div>");
        renderer.WriteLine(@$"<div class=""mt-3 flex justify-center"">
            <lite-youtube class=""w-full mx-4 my-4"" width=""560"" height=""315"" videoid=""{youtubeId}"" 
                style=""background-image:url('https://img.youtube.com/vi/{youtubeId}/maxresdefault.jpg')"">
            </lite-youtube>
            </div>
        </div>");
    }
}
```

That should be registered in `Configure.Ssg.cs` with the name we want to use for the container:

```csharp
MarkdigConfig.Set(new MarkdigConfig
{
    ConfigureContainers = config =>
    {
        // Add Custom Block or Inline containers
        config.AddBlockContainer("YouTube", new YouTubeContainer());
    }
});
```

After which it can be used in your Markdown documentation:

#### Input

```markdown
:::YouTube MRQMBrXi5Sc
Using Razor SSG to Create Websites in GitHub Codespaces
:::
```

#### Output

:::YouTube MRQMBrXi5Sc
Using Razor SSG to Create Websites in GitHub Codespaces
:::

### Custom Attributes

Since we use `WriteAttributes(obj)` to emit any attributes we're also able to customize the widget to use a custom **id**
and classes, e.g:

#### Input

```markdown
:::YouTube MRQMBrXi5Sc {.text-indigo-600}
Using Razor SSG to Create Websites in GitHub Codespaces
:::
```

#### Output

:::YouTube MRQMBrXi5Sc {.text-indigo-600}
Using Razor SSG to Create Websites in GitHub Codespaces
:::

## Implementing Inline Containers

Custom Inline Containers are useful when you don't need a to capture a block of content, like if we just want to display
a video without a title, e.g:

```markdown
::YouTube MRQMBrXi5Sc::
```

Inline Containers can be implemented with a Markdig `HtmlObjectRenderer<CustomContainerInline>`, e.g:

```csharp
public class YouTubeInlineContainer : HtmlObjectRenderer<CustomContainerInline>
{
    protected override void Write(HtmlRenderer renderer, CustomContainerInline obj)
    {
        var youtubeId = obj.FirstChild is Markdig.Syntax.Inlines.LiteralInline literalInline
            ? literalInline.Content.AsSpan().RightPart(' ').ToString()
            : null;
        if (string.IsNullOrEmpty(youtubeId))
        {
            renderer.WriteLine($"Missing YouTube Id, Usage ::YouTube <id>::");
            return;
        }
        renderer.WriteLine(@$"<div class=""mt-3 flex justify-center"">
            <lite-youtube class=""w-full mx-4 my-4"" width=""560"" height=""315"" videoid=""{youtubeId}"" 
                style=""background-image:url('https://img.youtube.com/vi/{youtubeId}/maxresdefault.jpg')"">
            </lite-youtube>
        </div>");
    }
}
```

That can be registered in `Configure.Ssg.cs` with:

```csharp
MarkdigConfig.Set(new MarkdigConfig
{
    ConfigureContainers = config =>
    {
        // Add Custom Block or Inline containers
        config.AddInlineContainer("YouTube", new YouTubeInlineContainer());
    }
});
```

Where it can then be used in your Markdown documentation:

#### Input

```markdown
::YouTube MRQMBrXi5Sc::
```

#### Output

::YouTube MRQMBrXi5Sc::


# Using Vue in Markdown
Source: https://razor-press.web-templates.io/vue-in-markdown

## Progressive Enhancement

Thanks to the Vue's elegant approach for progressively enhancing HTML content, Razor Press markdown documents can 
embed interactive reactive Vue components directly in Markdown which makes it possible to document the
[Vue Tailwind Component Library](/vue/autoquerygrid) and its interactive component examples, embedded directly in Markdown. 

## Markdown Documents are Vue Apps

We can embed Vue components directly in Markdown simply because all Markdown Documents are themselves Vue Apps, which by default 
are created with the same [/mjs/app.mjs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/wwwroot/mjs/app.mjs)
configuration that all Razor Pages uses. This allows using any 
[Vue DOM syntax](https://vuejs.org/guide/essentials/template-syntax.html) or global Vue components directly in Markdown, in the same
way that they're used in Vue Apps defined in Razor or HTML pages.


For example we can display the 
[GettingStarted.mjs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/wwwroot/mjs/components/GettingStarted.mjs) component
that's on the home page with:

#### Input

```html
<getting-started template="razor-press"></getting-started>
```

#### Output

<getting-started template="razor-press"></getting-started>

## Markdown with Custom Vue Apps

Pages that need advanced functionality beyond what's registered in the global App configuration can add additional
functionality by adding a JavaScript module with the same **path** and **filename** of the markdown page with
an `.mjs` extension:

```
/wwwroot/pages/<path>/<file>.mjs
```

This is utilized by most [/pages/vue](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp/wwwroot/pages/vue)
Markdown pages to handle the unique requirements of each page's live examples.

E.g. the [autoquerygrid.mjs](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/wwwroot/pages/vue/autoquerygrid.mjs)
uses a custom Vue App component that registers a custom **client** dependency and **Responsive** and **CustomBooking**
components that are only used in 
[/vue/autoquerygrid.md](https://github.com/NetCoreTemplates/razor-press/blob/main/MyApp/_pages/vue/autoquerygrid.md)
page to render the interactive live examples in the [/vue/autoquerygrid](/vue/autoquerygrid) page:

```js
import { onMounted } from "vue"
import { Authenticate } from "./dtos.mjs"
import { useAuth, useClient } from '@servicestack/vue'
import { JsonApiClient } from "@servicestack/client"
import Responsive from "./autoquerygrid/Responsive.mjs"
import CustomBooking from "./autoquerygrid/CustomBooking.mjs"

export default {
    install(app) {
        app.provide('client', JsonApiClient.create('https://blazor-gallery-api.jamstacks.net'))
    },
    components: {
        Responsive,
        CustomBooking,
    },
    setup() {
        const client = useClient()
        
        onMounted(async () => {
            const api = await client.api(new Authenticate({ 
                provider: 'credentials', userName:'admin@email.com', password:'p@55wOrd' }))
            if (api.succeeded) {
                const { signIn } = useAuth()
                signIn(api.response)
            }
        })
        return { }
    }
}
```

### Convert from Vue script setup

This is roughly equivalent to the sample below if coming from VitePress or other npm Vue project that uses Vue's 
compile-time syntactic [`<script setup>`](https://vuejs.org/api/sfc-script-setup.html):

```html
<script setup>
import { onMounted } from "vue"
import { Authenticate } from "./dtos.ts"
import { useAuth, useClient } from '@servicestack/vue'
import { JsonApiClient } from "@servicestack/client"
import Responsive from "./autoquerygrid/Responsive.vue"
import CustomBooking from "./autoquerygrid/CustomBooking.vue"

onMounted(async () => {
    const client = useClient()
    const api = await client.api(new Authenticate({ 
        provider: 'credentials', userName:'admin@email.com', password:'p@55wOrd' }))
    if (api.succeeded) {
        const { signIn } = useAuth()
        signIn(api.response)
    }
})
</script>
```

## Custom Styles in Markdown

If needed custom styles can also be added for individual pages by adding a `.css` file at the following location:

```
/wwwroot/pages/<path>/<file>.css
```


# Sidebars
Source: https://razor-press.web-templates.io/sidebars

## Main Sidebar

The sidebar defines the main navigation for your documentation, you can configure the sidebar menu in `_pages/sidebar.json`
which adopts the same structure as [VitePress Sidebars](https://vitepress.dev/reference/default-theme-sidebar#sidebar), e.g:

```json
[
  {
    "text": "Introduction",
    "link": "/",
    "children": [
      {
        "text": "What is Razor Press?",
        "link": "/what-is-razor-press"
      },
      {
        "text": "Structure",
        "link": "/structure"
      }
    ]
  },
  {
    "text": "Markdown",
    "children": [
      {
        "text": "Sidebars",
        "link": "/sidebars"
      }
    ]
  }
]
```

## Navigation Headings

Primary navigation headings can optionally have `"links"` to make them linkable and `"icon"` to render them
with a custom icon, e.g:

```json
{
    "icon": "<svg xmlns='http://www.w3.org/2000/svg'>....</svg>", 
    "text": "Markdown",
    "link": "/markdown/",
    "children": [
    ]
}
```

## Documentation Group Sidebars

If your happy to use the same document page title for its menu item label, you can use an implicitly generated Sidebar 
navigation like [/creatorkit/](/creatorkit/about) uses for its Sidebar navigation which can be ordered with the **order**
index defined in its frontmatter, e.g:

```yaml
title: About
order: 1
```

Which can also be grouped into different navigation sections using the **group** frontmatter, e.g:

```yaml
title: Overview
order: 6
group: Portal
```

### Custom Sidebars

For more flexibility a custom sidebar can be defined for each group by defining a `sidebar.json` in its folder 
`_pages/<group>/sidebar.json` which [/vue/](/vue/install) uses for its explicit Sidebar Navigation, e.g:

```json
[
  {
    "text": "Vue",
    "link": "/vue",
    "children": [
      {
        "text": "Install",
        "link": "/vue/install"
      }
    ]
  },
  {
    "text": "Component Gallery",
    "children": [
      {
        "text": "AutoQueryGrid",
        "link": "/vue/autoquerygrid"
      }
    ]
  }
]
```


# Redirects
Source: https://razor-press.web-templates.io/redirects

## Static HTML Page Redirects

The [redirects.json](https://github.com/NetCoreTemplates/razor-press/tree/main/MyApp/redirects.json) file allows you to
define a map of routes with what routes they should redirect to, e.g:

```json
{
    "/creatorkit": "/creatorkit/",
    "/vue": "/vue/"
}
```

When prerendering this will generate a `*.html` page for each mapping containing a 
[meta refresh](https://www.w3.org/TR/WCAG20-TECHS/H76.html) to perform a client-side redirect to the new route which will
work in all static file hosts and CDNs like GitHub Pages CDN.

Where it will redirect invalid routes like [/vue](https://razor-press.web-templates.io/vue) and
[/creatorkit](https://razor-press.web-templates.io/creatorkit) to their appropriate `/vue/` and `/creatorkit/` paths.

## Redirects in AWS S3

Alternatively if you deploy your static site to a smarter static file host like an AWS S3 bucket you can perform these
redirects on the server by defining them in 
[Custom Redirection Rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/how-to-page-redirect.html).


# Typesense Real-Time Search
Source: https://razor-press.web-templates.io/typesense

Many popular Open Source products use [Algolia DocSearch](https://docsearch.algolia.com) to power their real-time search
features, however, it's a less appealing product for commercial products which is a paid service with a per request 
pricing model that made it difficult to determine what costs would be in the long run.

<a class="flex flex-col items-center my-8" href="https://typesense.org">
    <svg fill="none" height="56" viewBox="0 0 250 56" width="250" xmlns="http://www.w3.org/2000/svg">
        <g fill="#1035bc"><path d="m15.0736 15.8466c.1105.5522.1657 1.0859.1657 1.6013 0 .4785-.0552.9938-.1657 1.546l-7.01225-.0552v18.5521c0 1.546.71779 2.319 2.15335 2.319h4.1963c.2577.6258.3865 1.2516.3865 1.8773 0 .6258-.0368 1.0123-.1104 1.1595-1.6932.2209-3.4417.3313-5.24538.3313-3.57055 0-5.35583-1.5276-5.35583-4.5828v-19.6564l-3.920246.0552c-.1104293-.5522-.165644-1.0675-.165644-1.546 0-.5154.0552147-1.0491.165644-1.6013l3.920246.0552v-5.7975c0-.99387.14724-1.69325.44172-2.09816.29448-.44172.86503-.66258 1.71165-.66258h1.4908l.33129.33129v8.28225z"/><path d="m41.7915 16.1227-7.5644 25.8957c-1.3988 4.7485-2.8896 8.0982-4.4724 10.0491s-3.9571 2.9264-7.1227 2.9264c-1.6196 0-3.1104-.2393-4.4724-.7178-.1104-1.0307.1841-2.0246.8834-2.9816 1.1411.4049 2.3559.6073 3.6442.6073 1.9509 0 3.4417-.6625 4.4724-1.9877 1.0307-1.3251 1.9693-3.3865 2.816-6.184l.1656-.5522c-.9571-.0736-1.6932-.2945-2.2086-.6626-.4785-.3681-.8834-1.049-1.2147-2.0429l-7.7301-24.2945c1.1411-.4785 1.9509-.7178 2.4295-.7178 1.0675 0 1.7853.6442 2.1534 1.9325l4.3619 13.8589c.1473.4418.9939 3.3129 2.5399 8.6135.0736.2577.2577.3865.5521.3865l6.7362-24.4049c.4786-.1472 1.1043-.2208 1.8773-.2208.8099 0 1.4908.1104 2.043.3313z"/><path d="m52.4009 41.135v10.9325c0 .9938-.1472 1.6932-.4417 2.0981-.2945.4418-.8834.6626-1.7669.6626h-1.4908l-.3312-.3313v-38.4846l.3312-.3313h1.4356c.8835 0 1.4724.2392 1.7669.7178.3313.4417.4969 1.1779.4969 2.2086v.276c2.2086-2.4662 4.8405-3.6994 7.8957-3.6994 3.1289 0 5.4847 1.27 7.0675 3.8099 1.5828 2.503 2.3743 5.9816 2.3743 10.4356 0 2.1717-.2945 4.1226-.8835 5.8527-.5521 1.7301-1.3067 3.2025-2.2638 4.4172-.9202 1.1779-1.9877 2.0981-3.2024 2.7607-1.2148.6258-2.4663.9387-3.7546.9387-2.5399 0-4.951-.7546-7.2332-2.2638zm0-17.9448v14.1902c2.2454 1.6564 4.362 2.4846 6.3497 2.4846 1.9878 0 3.6258-.8834 4.9141-2.6503 1.2884-1.7668 1.9326-4.4356 1.9326-8.0061 0-1.7669-.1657-3.2945-.497-4.5828-.2945-1.3252-.6994-2.4111-1.2147-3.2577-.5153-.8834-1.1227-1.5276-1.8221-1.9325-.6626-.4417-1.3804-.6626-2.1534-.6626-1.4724 0-2.8711.3865-4.1963 1.1595-1.3251.773-2.4294 1.8589-3.3129 3.2577z"/><path d="m97.6973 30.6442h-17.1166c.1841 6.2576 2.5583 9.3865 7.1227 9.3865 2.5031 0 5.1718-.773 8.0061-2.319.8099.7361 1.3068 1.6748 1.4909 2.8159-3.0184 2.0614-6.405 3.092-10.1596 3.092-1.9141 0-3.5521-.3497-4.9141-1.049-1.3619-.7362-2.4846-1.7301-3.3681-2.9816-.8466-1.2884-1.4724-2.7976-1.8773-4.5277-.4049-1.73-.6073-3.6257-.6073-5.6871 0-2.0981.2392-4.0122.7178-5.7423.5153-1.7301 1.2515-3.2209 2.2085-4.4724.9571-1.2515 2.0982-2.227 3.4234-2.9264 1.3619-.6994 2.9079-1.0491 4.638-1.0491 1.6932 0 3.2025.3129 4.5276.9387 1.362.589 2.4847 1.4172 3.3681 2.4847.9203 1.0306 1.6196 2.2822 2.0982 3.7546.4785 1.4355.7178 2.9816.7178 4.638 0 .6626-.0369 1.3067-.1105 1.9325-.0368.589-.092 1.1595-.1656 1.7117zm-17.1166-3.1473h13.2516v-.7178c0-2.5398-.5338-4.5828-1.6013-6.1288s-2.6687-2.319-4.8037-2.319c-2.0981 0-3.7362.8282-4.9141 2.4847-1.1411 1.6564-1.7852 3.8834-1.9325 6.6809z"/><path d="m103.381 41.0245c.036-.8098.257-1.6932.662-2.6503.442-.9938.939-1.7668 1.491-2.319 2.908 1.5828 5.466 2.3743 7.675 2.3743 1.214 0 2.19-.2393 2.926-.7178.773-.4786 1.16-1.1227 1.16-1.9326 0-1.2883-.994-2.319-2.982-3.092l-3.092-1.1595c-4.638-1.6932-6.957-4.3988-6.957-8.1166 0-1.3251.239-2.503.718-3.5337.515-1.0675 1.214-1.9693 2.098-2.7055.92-.773 2.006-1.362 3.258-1.7669 1.251-.4049 2.65-.6074 4.196-.6074.699 0 1.472.0553 2.319.1657.883.1104 1.767.2761 2.65.4969.884.1841 1.73.4049 2.54.6626s1.509.5337 2.098.8282c0 .9203-.184 1.8773-.552 2.8712s-.865 1.73-1.491 2.2086c-2.908-1.2884-5.429-1.9325-7.564-1.9325-.957 0-1.712.2392-2.264.7178-.552.4417-.828 1.0306-.828 1.7668 0 1.1411.92 2.043 2.761 2.7055l3.368 1.2148c2.429.8466 4.233 2.0061 5.411 3.4785s1.767 3.184 1.767 5.135c0 2.6135-.976 4.7116-2.927 6.2944-1.951 1.5461-4.748 2.3191-8.392 2.3191-3.571 0-6.921-.9019-10.049-2.7056z"/><path d="m151.772 31.5828h-15.239c.111 2.0246.571 3.6258 1.38 4.8037.847 1.1411 2.301 1.7117 4.362 1.7117 2.135 0 4.583-.6258 7.344-1.8773 1.067 1.1042 1.748 2.5582 2.043 4.3619-2.945 2.0982-6.479 3.1473-10.601 3.1473-3.902 0-6.865-1.1964-8.89-3.589-1.988-2.4294-2.981-6.0184-2.981-10.7669 0-2.2086.257-4.1963.773-5.9632.515-1.8036 1.269-3.3312 2.263-4.5828.994-1.2883 2.209-2.2822 3.644-2.9816 1.436-.6994 3.074-1.0491 4.915-1.0491 1.877 0 3.533.2945 4.969.8835 1.436.5521 2.65 1.3619 3.644 2.4294.994 1.0307 1.73 2.2638 2.209 3.6994.515 1.4356.773 3 .773 4.6933 0 .9202-.056 1.8036-.166 2.6503-.11.8098-.258 1.6196-.442 2.4294zm-10.656-11.5951c-2.871 0-4.417 2.1718-4.638 6.5154h9.165v-.6626c0-1.7669-.368-3.1841-1.104-4.2515-.736-1.0675-1.877-1.6013-3.423-1.6013z"/><path d="m182.033 24.5153v12.0368c0 2.3559.386 4.1043 1.159 5.2454-1.178 1.0307-2.595 1.5461-4.251 1.5461-1.583 0-2.669-.3497-3.258-1.0491-.589-.7362-.884-1.8773-.884-3.4233v-12.8651c0-1.6564-.202-2.8159-.607-3.4785s-1.159-.9939-2.264-.9939c-1.951 0-3.773.8835-5.466 2.6504v18.773c-.552.1104-1.141.184-1.767.2208-.589.0368-1.196.0552-1.822.0552s-1.251-.0184-1.877-.0552c-.589-.0368-1.16-.1104-1.712-.2208v-27.3313l.331-.3865h2.761c2.062 0 3.35 1.1043 3.865 3.3128 2.687-2.319 5.356-3.4785 8.006-3.4785 2.651 0 4.602.8651 5.853 2.5951 1.288 1.6933 1.933 3.9755 1.933 6.8466z"/><path d="m187.825 41.0245c.036-.8098.257-1.6932.662-2.6503.442-.9938.939-1.7668 1.491-2.319 2.908 1.5828 5.466 2.3743 7.675 2.3743 1.214 0 2.19-.2393 2.926-.7178.773-.4786 1.16-1.1227 1.16-1.9326 0-1.2883-.994-2.319-2.982-3.092l-3.092-1.1595c-4.638-1.6932-6.957-4.3988-6.957-8.1166 0-1.3251.239-2.503.718-3.5337.515-1.0675 1.214-1.9693 2.098-2.7055.92-.773 2.006-1.362 3.258-1.7669 1.251-.4049 2.65-.6074 4.196-.6074.699 0 1.472.0553 2.319.1657.883.1104 1.767.2761 2.65.4969.884.1841 1.73.4049 2.54.6626s1.509.5337 2.098.8282c0 .9203-.184 1.8773-.552 2.8712s-.865 1.73-1.491 2.2086c-2.908-1.2884-5.429-1.9325-7.564-1.9325-.957 0-1.712.2392-2.264.7178-.552.4417-.828 1.0306-.828 1.7668 0 1.1411.92 2.043 2.761 2.7055l3.368 1.2148c2.429.8466 4.233 2.0061 5.411 3.4785s1.767 3.184 1.767 5.135c0 2.6135-.976 4.7116-2.927 6.2944-1.951 1.5461-4.748 2.3191-8.392 2.3191-3.571 0-6.921-.9019-10.049-2.7056z"/><path d="m236.216 31.5828h-15.239c.111 2.0246.571 3.6258 1.38 4.8037.847 1.1411 2.301 1.7117 4.362 1.7117 2.135 0 4.583-.6258 7.344-1.8773 1.067 1.1042 1.748 2.5582 2.043 4.3619-2.945 2.0982-6.479 3.1473-10.601 3.1473-3.902 0-6.865-1.1964-8.89-3.589-1.988-2.4294-2.981-6.0184-2.981-10.7669 0-2.2086.257-4.1963.773-5.9632.515-1.8036 1.269-3.3312 2.263-4.5828.994-1.2883 2.209-2.2822 3.645-2.9816 1.435-.6994 3.073-1.0491 4.914-1.0491 1.877 0 3.533.2945 4.969.8835 1.436.5521 2.65 1.3619 3.644 2.4294.994 1.0307 1.73 2.2638 2.209 3.6994.515 1.4356.773 3 .773 4.6933 0 .9202-.055 1.8036-.166 2.6503-.11.8098-.258 1.6196-.442 2.4294zm-10.656-11.5951c-2.871 0-4.417 2.1718-4.638 6.5154h9.166v-.6626c0-1.7669-.369-3.1841-1.105-4.2515-.736-1.0675-1.877-1.6013-3.423-1.6013z"/><path d="m244.777 50.6871v-50.521455c.552-.1104299 1.178-.165645 1.878-.165645.736 0 1.417.0552151 2.042.165645v50.521455c-.625.1104-1.306.1657-2.042.1657-.7 0-1.326-.0553-1.878-.1657z"/></g>
    </svg>
</a>

We discovered [Typesense](https://typesense.org) as an appealing alternative which offers [simple cost-effective cloud hosting](https://cloud.typesense.org)
but even better, they also have an easy to use open source option for self-hosting or evaluation. Given its effortless integration, 
simplicity-focus and end-user UX, it quickly became our preferred way to navigate [docs.servicestack.net](https://docs.servicestack.net). 

To make it easier to adopt Typesense's amazing OSS Search product we've documented the approach we use to create and 
deploy an index of our site automatically using GitHub Actions that you could also utilize in your Razor Press websites.

Documentation search is a common use case which Typesense caters for with their 
[typesense-docsearch-scraper](https://github.com/typesense/typesense-docsearch-scraper) - a utility designed to easily 
scrape a website and post the results to a Typesense server to create a fast searchable index.

## Self hosting option

We recommend using running their [easy to use Docker image](https://hub.docker.com/r/typesense/typesense/) to run
an instance of their Typesense server, which you can run in a **t2.small** AWS EC2 instance or in a 
[Hetzner Cloud](https://www.hetzner.com/cloud) VM for a more cost effective option.

Trying it locally, we used the following commands to spin up a local Typesense server ready to scrape out docs site.

```sh
mkdir /tmp/typesense-data
docker run -p 8108:8108 -v/tmp/data:/data typesense/typesense:0.21.0 \
    --data-dir /data --api-key=<temp-admin-api-key> --enable-cors
```

To check that the server is running, we can open a browser at `/health` and we get back 200 OK with `ok: true`.

The Typesense server has a [REST API](https://typesense.org/docs/0.21.0/api) which can be used to manage the indexes you create. 
Or if you use their cloud offering, you can use their web dashboard to monitor and manage your index data.

## Populating the index

With your local server is running, you can scrape your docs site using the 
[typesense-docsearch-scraper](https://github.com/typesense/typesense-docsearch-scraper). 
This needs some configuration to tell the scraper:

- Where the Typesense server is
- How to authenticate with the Typesense server
- Where the docs website is
- Rules for the scraper to follow extracting information from the docs website

These [pieces of configuration come from 2 sources](https://github.com/ServiceStack/docs/tree/master/search-server/typesense-scraper). 
A [.env](https://github.com/ServiceStack/docs/blob/master/search-server/typesense-scraper/typesense-scraper.env) file 
related to the Typesense server information and
a [.json](https://github.com/ServiceStack/docs/blob/master/search-server/typesense-scraper/typesense-scraper-config.json)
file related to what site will be getting scraped.

With a Typesense running locally on port **8108**, we configure the `.env` file with the following information:

```
TYPESENSE_API_KEY=${TYPESENSE_API_KEY}
TYPESENSE_HOST=localhost
TYPESENSE_PORT=8108
TYPESENSE_PROTOCOL=http
```

Next, we have to configure the `.json` config for the scraper. 
The **typesense-docsearch-scraper** has [an example of this](https://github.com/typesense/typesense-docsearch-scraper/blob/master/configs/public/typesense_docs.json)
config in their repository.

The default selectors will need to match the your websites HTML, which for Razor Press sites can start with the configuration,
updated with your website domains:

```json
{
  "index_name": "typesense_docs",
  "allowed_domains": ["docs.servicestack.net"],
  "start_urls": [
    {
      "url": "https://docs.servicestack.net/"
    }
  ],
  "selectors": {
    "default": {
      "lvl0": "h1",
      "lvl1": ".content h2",
      "lvl2": ".content h3",
      "lvl3": ".content h4",
      "lvl4": ".content h5",
      "text": ".content p, .content ul li, .content table tbody tr"
    }
  },
  "scrape_start_urls": false,
  "strip_chars": " .,;:#"
}
```

With both the configuration files ready to use, we can run the scraper itself. The scraper is also available using the 
docker image `typesense/docsearch-scraper` which we can pass our configuration to, using the following command:

```sh
docker run -it --env-file typesense-scraper.env \
    -e "CONFIG=$(cat typesense-scraper-config.json | jq -r tostring)" \
    typesense/docsearch-scraper
```

Here `-i` is used to reference a local `--env-file` and use `cat` and `jq` used to populate the `CONFIG` environment variable 
with the `.json` config file.

## Docker networking

We had a slight issue here since the scraper itself is running in Docker via WSL and `localhost` doesn't resolve to our 
host machine to find the Typesense server also running in Docker.
Instead we need to point the scraper to the Typesense server using the Docker local IP address space of `172.17.0.0/16` 
for it to resolve without additional configuration.

We can see in the output of the Typesense server that it is running using `172.17.0.2`. We can swap the `localhost` 
with this IP address after which we see the communication between the servers flowing:

```
DEBUG:typesense.api_call:Making post /collections/typesense_docs_1635392168/documents/import
DEBUG:typesense.api_call:Try 1 to node 172.17.0.2:8108 -- healthy? True
DEBUG:urllib3.connectionpool:Starting new HTTP connection (1): 172.17.0.2:8108
DEBUG:urllib3.connectionpool:http://172.17.0.2:8108 "POST /collections/typesense_docs_1635392168/documents/import HTTP/1.1" 200 None
DEBUG:typesense.api_call:172.17.0.2:8108 is healthy. Status code: 200
> DocSearch: https://docs.servicestack.net/azure 22 records)
DEBUG:typesense.api_call:Making post /collections/typesense_docs_1635392168/documents/import
DEBUG:typesense.api_call:Try 1 to node 172.17.0.2:8108 -- healthy? True
DEBUG:urllib3.connectionpool:Starting new HTTP connection (1): 172.17.0.2:8108
DEBUG:urllib3.connectionpool:http://172.17.0.2:8108 "POST /collections/typesense_docs_1635392168/documents/import HTTP/1.1" 200 None
```

The scraper crawls the docs site following all the links in the same domain to get a full picture of all the content of our docs site.
This takes a minute or so, and in the end we can see in the Typesense sever output that we now have **committed_index: 443**.

```
_index: 443, applying_index: 0, pending_index: 0, disk_index: 443, pending_queue_size: 0, local_sequence: 44671
I20211028 03:39:40.402626   328 raft_server.h:58] Peer refresh succeeded!
```

## Searching content

After you have a Typesense server with an index full of content, you'll want to be able to use it to search your docs site.
You can query the index using `curl` which needs to known 3 key pieces of information:

- Collection name, eg `typesense_docs`
- Query term, `?q=test`
- What to query, `&query_by=content`

```sh
curl -H 'x-typesense-api-key: <apikey>' \
    'http://localhost:8108/collections/typesense_docs/documents/search?q=test&query_by=content'
```

The collection name and `query_by` come from how the scraper was configured. The scraper was posting data to the
`typesense_docs` collection and populating various fields, eg `content`.

Which as it returns JSON can be easily queried in JavaScript using **fetch**:

```js
fetch('http://localhost:8108/collections/typesense_docs/documents/search?q='
    + encodeURIComponent(query) + '&query_by=content', {
    headers: {
        // Search only API key for Typesense.
        'x-typesense-api-key': 'TYPESENSE_SEARCH_ONLY_API_KEY'
    }
})
```

In the above we have also used a different name for the API key token, this is important since the `--api-key` specified to the running Typesense server is the admin API key. You don't want to expose this to a browser client since they will have the ability to create,update and delete your collections or documents.

Instead we want to generate a "Search only" API key that is safe to share on a browser client. This can be done using the Admin API key and the following REST API call to the Typesense server.

```bash
curl 'http://localhost:8108/keys' -X POST \
  -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
  -H 'Content-Type: application/json' \
  -d '{"description": "Search only","actions": ["documents:search"],"collections":["*"]}'
```

Now we can share this generated key safely to be used with any of our browser clients.

## Keeping the index updated

A problem that becomes apparent when running the scraper is that it increases the size of the index since it currently 
doesn't detect and update existing documents. It wasn't clear if this is possible to configure from the current scraper, 
but we needed a way to achieve the following goals:

- Update the search index automatically soon after docs have been changed
- Don't let the index grow too big to avoid manual intervention
- Have high uptime so documentation search is always available

Typesense server itself performs extremely well, so a full update from the scraper doesn't generate an amount of load. 
However, every additional scrape uses additional disk space and memory that will eventually require periodically 
resetting and repopulating the index.

One option is to switch to a new collection everytime the documentation is updated and delete the old collection,
adopting a workflow that looks something like: 

1. Docs are updated
2. Publish updated docs
3. Create new collection, store new and old names
4. Scrape updated docs
5. Update client with new collection
6. Delete old collection

However this would require orchestration across a number of GitHub Action workflows which we anticipated would be 
fragile and non-deterministic as to how long it will take to scrape, update, and deploy our changes.

## Read-only Docker container

The approach we ended up adopting was to develop and deploy read only Typesense Docker images containing an immutable copy 
of the index data in it as part of the GitHub Action deployments.

In the case of Typesense, when it starts up, it reads from its `data` directory from disk to populate the index in 
memory and since our index is small and only updates when our documentation is updated, we can simplify the management 
of the index data by **baking it into the docker image**.

This has several key advantages.

- Disaster recovery doesn't need any additional data management.
- Shipping an updated index is a normal ECS deployment.
- Zero down time deployments.
- Index is of a fixed size once deployed.

## Typesense Performance

Search on our documentation site is a very light workload for Typesense. Running as an ECS service on a 2 vCPU instance, 
the service struggled to get close to **1%** whilst serving constant typeahead searching.

![](https://servicestack.net/img/posts/typesense/typesense-cpu-utilization.png)

Since our docs site index is small (500 pages), the memory footprint is also tiny and stable at **~50MB** or **~10%** of the the 
service's soft memory limit.

![](https://servicestack.net/img/posts/typesense/typesense-memory-utilization.png)

This means we will be able to host this using a single EC2 instance among various other or the ServiceStack hosted 
example applications and use the same deployment patterns we've shared in our
[GitHub Actions templates](https://docs.servicestack.net/mix-github-actions-aws-ecs).

[![](https://raw.githubusercontent.com/ServiceStack/docs/master/docs/images/mix/cloudcraft-host-digram-release-ecr-aws.png)](https://docs.servicestack.net/mix-github-actions-aws-ecs)

Whilst this approach of shipping an index along with the Docker image isn't practical for large or 'living' indexes, 
many small to medium-sized documentation sites would likely benefit from the simplified approach of deploying readonly
Docker images.

## GitHub Actions Workflow

To create our own Docker image for our search server we need to perform the following tasks in our GitHub Action:

1. Run a local Typesense server in the GitHub Action using Docker
2. Scrape our hosted docs populating the local Typesense server
3. Copy the `data` folder of our local Typesense server during `docker build`

Which is done with:

```sh
mkdir -p ${GITHUB_WORKSPACE}/typesense-data
cp ./search-server/typesense-server/Dockerfile ${GITHUB_WORKSPACE}/typesense-data/Dockerfile
cp ./search-server/typesense-scraper/typesense-scraper-config.json typesense-scraper-config.json
envsubst < "./search-server/typesense-scraper/typesense-scraper.env" > "typesense-scraper-updated.env"
docker run -d -p 8108:8108 -v ${GITHUB_WORKSPACE}/typesense-data/data:/data \
    typesense/typesense:0.21.0 --data-dir /data --api-key=${TYPESENSE_API_KEY} --enable-cors &
# wait for typesense initialization
sleep 5
docker run -i --env-file typesense-scraper-updated.env \
    -e "CONFIG=$(cat typesense-scraper-config.json | jq -r tostring)" typesense/docsearch-scraper
```

Our `Dockerfile` then takes this data from the `data` folder during build.

```Dockerfile
FROM typesense/typesense:0.21.0

COPY ./data /data
```

To avoid updating our search client between updates we also want to use the same **search-only API Key** everytime 
a new server is created. This can be achieved by specifying `value` in the `POST` command sent to the local Typesense server:

```sh
curl 'http://172.17.0.2:8108/keys' -X POST \
  -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
  -H 'Content-Type: application/json' \
  -d '{"value":<search-api-key>,"description":"Search only","actions":["documents:search"],"collections":["*"]}'
```

If you're interested in adopting a similar approach you can find the whole GitHub Action workflow in our 
[search-index-update.yml](https://github.com/ServiceStack/docs/blob/master/.github/workflows/search-index-update.yml) 
workflow.

## Search UI Dialog

After docs are indexed the only thing left to do is display the results. We set out to create a comparable UX to
Algolia's doc search dialog which we've implemented in the
[Typesense.mjs](https://github.com/ServiceStack/docs.servicestack.net/blob/main/MyApp/wwwroot/mjs/components/Typesense.mjs)
Vue component which you can register as a global component in your 
[app.mjs](https://github.com/ServiceStack/docs.servicestack.net/blob/main/MyApp/wwwroot/mjs/app.mjs):


```js
import Typesense from "./components/Typesense.mjs"

const Components = {
    //...
    Typesense,
}
```

Which renders as a **Search Button** that we've added next to our **Dark Mode Toggle** button in our 
[Header.cshtml](https://github.com/ServiceStack/docs.servicestack.net/blob/main/MyApp/Pages/Shared/Header.cshtml):

```html
<div class="hidden sm:ml-6 sm:flex sm:items-center">
    <typesense></typesense>
    <dark-mode-toggle class="ml-2 w-10"></dark-mode-toggle>
</div>
```

![](https://servicestack.net/img/posts/typesense/typesense-header.png)

The button also encapsulates the dialog component which uses Typesense REST API to query to our typesense instance:

```js
fetch('https://search.docs.servicestack.net/collections/typesense_docs/documents/search?q='
  + encodeURIComponent(query.value)
  + '&query_by=content,hierarchy.lvl0,hierarchy.lvl1,hierarchy.lvl2,hierarchy.lvl3&group_by=hierarchy.lvl0', {
    headers: {
      // Search only API key for Typesense.
      'x-typesense-api-key': 'TYPESENSE_SEARCH_ONLY_API_KEY'
    }
})
```

This instructs Typesense to search through each documents content and h1-3 headings, grouping results by its page title.
Refer to the [Typesense API Search Reference](https://typesense.org/docs/0.21.0/api/documents.html#search) to learn how
to further fine-tune search results for your use-case.

## Search Results

![](https://servicestack.net/img/posts/typesense/typesense-dart.gif)

The results are **excellent**, [see for yourself](https://docs.servicestack.net) by using the search at the top right or 
using `Ctrl+K` shortcut key on [docs.servicestack.net](https://docs.servicestack.net).

It also does a great job handling typos and has quickly become the fastest way to navigate our extensive documentation
that we hope also serves useful for implementing Typesense real-time search in your own documentation websites.


# Installation
Source: https://razor-press.web-templates.io/vue/install

## Manual Installation

**@servicestack/vue** can be added to existing Vue SPA Apps by installing via npm:

```bash
$ npm install @servicestack/vue
```

Where it will also install its **vue** and **@servicestack/client** dependencies.

## Installation-less option

Alternatively you can take advantage of modern browsers [JS Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) support to
use these libraries without installation by registering an [importmap](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap) to define where it should load the ESM builds of these libraries from, e.g:

```html
<script type="importmap">
{
    "imports": {
        "vue":                  "https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js",
        "@servicestack/client": "https://unpkg.com/@servicestack/client@2/dist/servicestack-client.min.mjs",
        "@servicestack/vue":    "https://unpkg.com/@servicestack/vue@3/dist/servicestack-vue.min.mjs"
    }
}
</script>
```

For intranet Web Apps that need to work without internet access, save and reference local copies of these libraries, e.g:

```html
<script type="importmap">
{
    "imports": {
        "vue":                  "/lib/mjs/vue.mjs",
        "@servicestack/client": "/lib/mjs/servicestack-client.mjs",
        "@servicestack/vue":    "/lib/mjs/servicestack-vue.mjs"
    }
}
</script>
```

## @Html.ImportMap

Razor Pages or MVC Apps can use the `Html.ImportMaps()` to use local debug builds during development and optimal CDN hosted minified production builds in production:

```csharp
@Html.ImportMap(new()
{
    ["vue"]                  = ("/lib/mjs/vue.mjs",                 "https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js"),
    ["@servicestack/client"] = ("/lib/mjs/servicestack-client.mjs", "https://unpkg.com/@servicestack/client@2/dist/servicestack-client.min.mjs"),
    ["@servicestack/vue"]    = ("/lib/mjs/servicestack-vue.mjs",    "https://unpkg.com/@servicestack/vue@3/dist/servicestack-vue.min.mjs")
})
```

> It's recommended to use exact versions to eliminate redirect latencies and to match the local version your App was developed against

### Polyfill for Safari

Unfortunately Safari is the last modern browser to [support import maps](https://caniuse.com/import-maps) which is only now in
Technical Preview. Luckily this feature can be polyfilled with the pre-configured [ES Module Shims](https://github.com/guybedford/es-module-shims):

```html
@if (Context.Request.Headers.UserAgent.Any(x => x.Contains("Safari") && !x.Contains("Chrome")))
{
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>
}
```

## Registration

Then register the `@servicestack/vue` component library with your Vue app with:

```js
import { JsonApiClient } from "@servicestack/client"
import ServiceStackVue from "@servicestack/vue"

const client = JsonApiClient.create()

const app = createApp(component, props)
app.provide('client', client)
app.use(ServiceStackVue)

//...
app.mount('#app')
```

The **client** instance is used by API-enabled components to call your APIs using the [/api predefined route](/routing#json-api-pre-defined-route). ServiceStack Apps not running on .NET 6+ or have the **/api** route disabled should use
`JsonServiceClient` instead:

```js
const client = new JsonServiceClient()
```

## Not using Vue Router

Non SPA Vue Apps that don't use [Vue Router](https://router.vuejs.org) should register a replacement `<router-link>` component
that uses the browser's native navigation in [navigational components](/vue/navigation):

```js
app.component('RouterLink', ServiceStackVue.component('RouterLink'))
```


# AutoQueryGrid Component
Source: https://razor-press.web-templates.io/vue/autoquerygrid

<div class="flex justify-center">
    <lite-youtube class="w-full mx-4 my-4" width="560" height="315" videoid="znCoC-Ct0Ps" style="background-image: url('https://img.youtube.com/vi/znCoC-Ct0Ps/maxresdefault.jpg')"></lite-youtube>
</div>

<api-reference component="AutoQueryGrid<Model>"></api-reference>
## Default CRUD

By default you can create an AutoQueryGrid that allows authorized users the ability to Create, Read, Update & Delete records 
with just the DataModel, e.g:

```html
<AutoQueryGrid type="Booking" />
```
<div class="not-prose prose-table">
<auto-query-grid type="Booking"></auto-query-grid>
</div>

This will utilize your App's existing [AutoQuery APIs](/autoquery/rdbms) for the specified DataModel to enable its CRUD functionality.

<api-reference component="AutoQueryGrid<Model>"></api-reference>
## Read Only

You can use `apis` to limit which AutoQuery APIs AutoQueryGrid should use, so if only the AutoQuery DTO is provided, the AutoQueryGrid will only be browsable in **read-only** mode:

```html
<AutoQueryGrid type="Booking" apis="QueryBookings"  />
```
<div class="not-prose prose-table">
<auto-query-grid type="Booking" apis="QueryBookings"></auto-query-grid>
</div>

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Table Styles
</h2>

The same [DataGrid Table Styles](/vue/datagrid#table-styles) can also be used to style AutoQueryGrid, e.g:

```html
<AutoQueryGrid type="Booking" tableStyle="verticalLines,uppercaseHeadings" />
```
<div class="not-prose prose-table">
<auto-query-grid type="Booking" tableStyle="verticalLines,uppercaseHeadings"></auto-query-grid>
</div>

**Custom Styles**

The AutoQueryGrid's appearance is further customizable with the property classes & functions below:

```ts
defineProps<{
  toolbarButtonClass: string
  tableStyle: "simple" | "fullWidth" | "stripedRows" | "whiteBackground" | "uppercaseHeadings" | "verticalLines"
  gridClass: string
  grid2Class: string
  grid3Class: string
  grid4Class: string
  tableClass: string
  theadClass: string
  tbodyClass: string
  theadRowClass: string
  theadCellClass: string

  rowClass:(model:any,i:number) => string
  rowStyle:(model:any,i:number) => StyleValue
}>()
```

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Custom AutoQueryGrid
</h2>

Different AutoQueryGrid features can be hidden with `hide` and functionality disabled with `deny`, e.g:

```html
<AutoQueryGrid type="Booking" hide="pagingNav,copyApiUrl,downloadCsv" deny="filtering" />
```

<div class="not-prose prose-table">
<auto-query-grid type="Booking" hide="pagingNav,copyApiUrl,downloadCsv" deny="filtering"></auto-query-grid>
</div>

Features that can be hidden and disabled include:

```ts
defineProps<{
    deny: "filtering" | "queryString" | "queryFilters"
    hide: "toolbar"   | "preferences" | "pagingNav" | "pagingInfo" | "downloadCsv" | "refresh" 
       | "copyApiUrl" | "filtersView" | "newItem"   | "resetPreferences" 
}>()
```

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Global AutoQueryGrid Configuration
</h2>

These features can also be disabled at a global level, applying to all `<AutoQueryGrid>` components with [setConfig](/vue/use-config), e.g:

```js
const { setAutoQueryGridDefaults } = useConfig()

setAutoQueryGridDefaults({
  hide: ['pagingNav','copyApiUrl','downloadCsv']
})
```

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Limit Columns
</h2>

By default AutoQueryGrid displays all public properties returned in its AutoQuery API which can be further limited with `selected-columns`:

```html
<AutoQueryGrid type="Booking" selectedColumns="id,name,roomType,roomNumber,cost" />
```
<div class="not-prose prose-table">
<auto-query-grid type="Booking" selectedColumns="id,name,roomType,roomNumber,cost"></auto-query-grid>
</div>

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Simple Responsive Columns
</h2>

Using `visible-from` is a simple way to enable a responsive DataGrid by specifying at which [Tailwind breakpoints](https://tailwindcss.com/docs/responsive-design)
columns should be visible from and `header-titles` to use friendlier aliases for different columns, e.g:

```html
<AutoQueryGrid type="Booking" 
  selectedColumns="id,name,roomType,roomNumber,cost,bookingStartDate,bookingEndDate" 
  :headerTitles="{ roomNumber:'Room', bookingStartDate:'Start', bookingEndDate:'End' }"
  :visibleFrom="{ bookingStartDate:'lg', bookingEndDate:'xl' }" />
```
<div class="not-prose prose-table">
<auto-query-grid type="Booking" 
  selectedColumns="id,name,roomType,roomNumber,cost,bookingStartDate,bookingEndDate" 
  :headerTitles="{ roomNumber:'Room', bookingStartDate:'Start', bookingEndDate:'End' }"
  :visibleFrom="{ bookingStartDate:'lg', bookingEndDate:'xl' }"></auto-query-grid>
</div>

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Custom Responsive Columns
</h2>

Which columns are displayed and how they're formatted are further customizable with `<template #column>` slots:

```html
<AutoQueryGrid type="Booking" :visibleFrom="{ name:'xl', bookingStartDate:'sm', bookingEndDate:'xl', createdBy:'2xl' }">
    <template #id="{ id }">
        <span class="text-gray-900" v-html="id"></span>
    </template>
    
    <template #name="{ name }" v-html="name"></template>
    
    <template #roomNumber-header>
        <span class="hidden lg:inline">Room </span>No
    </template>

    <template #cost="{ cost }">
        <span v-html="currency(cost)"></span>
    </template>
    
    <template #bookingStartDate-header>
        Start<span class="hidden lg:inline"> Date</span>
    </template>
    
    <template #bookingEndDate-header>
        End<span class="hidden lg:inline"> Date</span>
    </template>

    <template #createdBy-header>
        Employee
    </template>
    <template #createdBy="{ createdBy }" v-html="createdBy"></template>
</AutoQueryGrid>
```

<responsive class="not-prose mb-4"></responsive>

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Custom Functionality
</h2>

The column template slots can be leveraged to implement custom functionality, e.g. instead of navigating to separate pages to manage related data
we can use a custom column to manage Booking Coupons from within the same grid, e.g:

```html
<AutoQueryGrid type="Booking" selectedColumns="id,name,cost,bookingStartDate,bookingEndDate,discount">
    <template #discount="{ discount }">
        <TextLink v-if="discount" class="flex items-end" @click.stop="showCoupon(discount.id)" :title="discount.id">
            <Icon class="w-5 h-5 mr-1" type="Coupon" />
            <PreviewFormat :value="discount.description" />
        </TextLink>
    </template>
</AutoQueryGrid>
<AutoEditForm v-if="coupon" type="UpdateCoupon" v-model="coupon" @done="close" @save="close" />

<script setup lang="ts">
import { ref } from "vue"
import { useClient } from "@servicestack/vue"
import { QueryCoupons } from "dtos"

const client = useClient()
const coupon = ref()

async function showCoupon(id:string) {
    const api = await client.api(new QueryCoupons({ id }))
    if (api.succeeded) {
        coupon.value = api.response!.results[0]
    }
}

const close = () => coupon.value = null
</script>
```

<custom-booking class="not-prose"></custom-booking>

<h2 class="pt-8 mb-4 text-2xl font-semibold text-gray-900 dark:text-gray-100">
  Data Reference Labels
</h2>

[AutoQuery](/autoquery/rdbms) is able to infer relationships from the [POCO References](/ormlite/reference-support) of your Data Models where if your DataModel includes `[Reference]` attributes so that its related Data is returned in your AutoQuery APIs, AutoQueryGrid will be able to make use of it to render the Contacts & Job Names and Icons instead of just the plain Foreign Key Ids.

An example of this in the [JobApplications](https://blazor-gallery.servicestack.net/locode/QueryJobApplications) DataModel DTO:

```csharp
[Icon(Svg = Icons.Application)]
public class JobApplication : AuditBase
{
    [AutoIncrement]
    public int Id { get; set; }

    [References(typeof(Job))]
    public int JobId { get; set; }

    [References(typeof(Contact))]
    public int ContactId { get; set; }

    [Reference]
    [Format(FormatMethods.Hidden)]
    public Job Position { get; set; }

    [Reference]
    [Format(FormatMethods.Hidden)]
    public Contact Applicant { get; set; }

    [Reference]
    public List<JobApplicationComment> Comments { get; set; }

    public DateTime AppliedDate { get; set; }

    public JobApplicationStatus ApplicationStatus { get; set; }
    //...
}
```

Which AutoQueryGrid uses to automatically display the Job and Contact name instead of their ids:

```html
<AutoQueryGrid type="JobApplication" :prefs="{take:5}" />
```
<div class="not-prose prose-table">
<auto-query-grid type="JobApplication" :prefs="{take:5}"></auto-query-grid>
</div>

With the original ids are discoverable by hovering over the Job & Contact labels. 

## Reference Fields

By default AutoQuery will infer using the first string column of the related table for its label, this information can also be explicitly defined
with the `[Ref]` attribute, e.g:

```csharp
public class JobApplication : AuditBase
{
    [AutoIncrement]
    public int Id { get; set; }

    [References(typeof(Job))]
    [Ref(Model=nameof(Job), RefId=nameof(Job.Id), RefLabel=nameof(Job.Title))]
    public int JobId { get; set; }

    [References(typeof(Contact))]
    [Ref(Model=nameof(Contact), RefId=nameof(Contact.Id), RefLabel=nameof(Contact.DisplayName))]
    public int ContactId { get; set; }
    //...
}
```

Alternatively you can use `[Ref(None=true)]` to disable any implicit inferences and render the FK property Ids as-is.

When displaying referential data you can tell AutoQueryGrid to hide rendering the complex data references as well columns 
using `[Format(FormatMethods.Hidden)]`. 

## AutoQueryGrid Template Slots

AutoQueryGrid supports a number of [Vue slots](https://vuejs.org/guide/components/slots.html) to customize its built-in UIs, 
including `formheader` and `formfooter` slots to insert custom content before and after the Auto Create & Edit components forms:

```html
<template #formheader="{ form, type, apis, model, id }">
<template #formfooter="{ form, type, apis, model, id }">
```

This feature is used to implement [Locode's Audit History UI](/locode/auditing) for displaying the Audit History of each record in the bottom of the 
Edit Form for Authorized Users, implemented with:

```html
<AutoQueryGrid :key="store.opDataModel" ref="grid" :type="store.opDataModel">
    <template #formfooter="{ form, type, apis, model, id }">
        <AuditEvents v-if="form === 'edit' && canAccessCrudEvents" class="mt-4" :key="id" :type="type" :id="id" />
    </template>
</AutoQueryGrid>
```

Which loads the [AuditEvents.mjs](https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack/src/ServiceStack/modules/locode/components/AuditEvents.mjs)
component at the bottom of **Edit** forms, allowing Admin Users to inspect the Audit History of each record:

[![](https://servicestack.net/img/pages/vue/audit-history-job.png)](/locode/auditing)

Alternatively you can replace the entire Create and Edit Forms used with the `createform` and `editforms` slots:

```html
<template #createform="{ form, apis, type }">
<template #editform="{ form, apis, type }">
```

Additional toolbar buttons can be added with the `toolbarbuttons` slot, e.g:

```html
<template #toolbarbuttons="{ toolbarButtonClass }">
  <div class="pl-2 mt-1">
      <button type="button" @click="customAction" :class="toolbarButtonClass">
        <span class="whitespace-nowrap">My Action</span>
      </button>
  </div>
</template>
```

Alternatively you can replace the entire toolbar with your own with:

```html
<template #toolbar>
```

All other template slots are passed down to the embedded [DataGrid](/vue/datagrid) component where they can be used to customize column headers and cells.

## AutoQueryGrid Properties

Additional customizations available using AutoQueryGrid properties include:

```ts
defineProps<{
    filterDefinitions?: AutoQueryConvention[]
    id?: string
    apis?: string|string[]
    type?: string|InstanceType<any>|Function
    prefs?: ApiPrefs

    deny?: string|GridAllowOptions|GridAllowOptions[]
    hide?: string|GridShowOptions|GridShowOptions[]
    
    selectedColumns?:string[]|string
    toolbarButtonClass?: string
    tableStyle?: TableStyleOptions
    gridClass?: string
    grid2Class?: string
    grid3Class?: string
    grid4Class?: string
    tableClass?: string
    theadClass?: string
    tbodyClass?: string
    theadRowClass?: string
    theadCellClass?: string

    headerTitle?:(name:string) => string
    headerTitles?: {[name:string]:string}
    visibleFrom?: {[name:string]:Breakpoint}
    rowClass?:(model:any,i:number) => string
    rowStyle?:(model:any,i:number) => StyleValue | undefined

    apiPrefs?: ApiPrefs
    canFilter?:(column:string) => boolean
    disableKeyBindings?:(column:string) => boolean
    configureField?: (field:InputProp) => void
    skip?: number
    create?: boolean
    edit?: string|number
}>()
```

## AutoQueryGrid Events

Whilst the `headerSelected` and `rowSelected` events can be used to invoke custom functionality when column headers and rows are selected:

```ts
defineEmits<{
    (e: "headerSelected", name:string, ev:Event): void
    (e: "rowSelected", item:any, ev:Event): void
}>()
```

## Powers Locode

AutoQueryGrid is already used extensively and is the key component that enables [Locode's](https://docs.servicestack.net/locode/) Instant Auto UI to manage your App's 
AutoQuery CRUD APIs.

[![](https://servicestack.net/img/pages/vue/blazor-gallery-contact.png)](https://docs.servicestack.net/locode/)


# DataGrid Component
Source: https://razor-press.web-templates.io/vue/datagrid

<api-reference component="DataGrid<Model>"></api-reference>
## Default

In its most simple usage the DataGrid component can be used to render typed collections:

```html
<DataGrid :items="tracks" />

<script>
const tracks = [
    track("Everythings Ruined", "Faith No More", "Angel Dust", 1992),
    track("Lightning Crashes", "Live", "Throwing Copper", 1994),
    track("Heart-Shaped Box", "Nirvana", "In Utero", 1993),
    track("Alive", "Pearl Jam", "Ten", 1991),
]
</script>
```

Which by default will display all object properties:

<div class="not-prose">
<data-grid :items="tracks" class="mb-4"></data-grid>
</div>

Use **selected-columns** to control which columns to display and **header-titles** to use different column names:

```html
<DataGrid :items="tracks" :selected-columns="['year','album','name','artist']" 
          :header-titles="{ name:'Track' }" />
```
<div class="not-prose">
<data-grid :items="tracks" :selected-columns="['year','album','name','artist']" :header-titles="{ name:'Track' }" class="mb-4"></data-grid>
</div>

Which for a wrist-friendly alternative also supports a string of comma delimited column names, e.g:

```html
<DataGrid :items="tracks" selected-columns="year,album,name,artist" />
```

## Simple Customizations

Which columns are shown and how they're rendered is customizable with custom `<template #column>` definitions:

```html
<DataGrid :items="forecasts" class="max-w-screen-md" :table-style="['stripedRows','uppercaseHeadings']"
          :header-titles="{ temperatureC:'TEMP. (C)', temperatureF:'TEMP. (F)' }">
    <template #date-header>
        <span class="text-indigo-600">Date</span>
    </template>
    <template #date="{ date }">
        {{ new Intl.DateTimeFormat().format(new Date(date)) }}
    </template>
    <template #temperatureC="{ temperatureC }">
        {{ temperatureC }}&deg;
    </template>
    <template #temperatureF="{ temperatureF }">
        {{ temperatureF }}&deg;
    </template>
    <template #summary="{ summary }">{{ summary }}</template>
</DataGrid>
```

<custom class="not-prose mb-4"></custom>

Column names can be changed with a **header-titles** alias mapping, or dynamically with a **header-title** mapping function.

Alternatively for more advanced customizations, custom `<template #column-header>` definitions can be used 
to control how column headers are rendered.

If any custom column or header definitions are provided, only those columns will be displayed. 
Alternatively specify an explicit array of column names in **selected-columns**
to control the number and order or columns displayed.

## Responsive

A more advanced example showing how to implement a responsive datagrid defining what columns and Headers
are visible at different screen sizes using **visible-from** to specify which columns to show 
from different Tailwind responsive breakpoints and `<template #column-header>` definitions to 
collapse column names at small screen sizes:

```html
<template>
<DataGrid :items="bookings" 
      :visible-from="{ name:'xl', bookingStartDate:'sm', bookingEndDate:'xl' }"
      @header-selected="headerSelected"
      @row-selected="rowSelected" :is-selected="row => selected == row.id">
    <template #id="{ id }">
        <span class="text-gray-900" v-html="id"></span>
    </template>
    
    <template #name="{ name }" v-html="name"></template>
    
    <template #roomNumber-header>
        <span class="hidden lg:inline">Room </span>No
    </template>

    <template #cost="{ cost }" v-html="currency(cost)"></template>
    
    <template #bookingStartDate-header>
        Start<span class="hidden lg:inline"> Date</span>
    </template>
    
    <template #bookingEndDate-header>
        End<span class="hidden lg:inline"> Date</span>
    </template>

    <template #createdBy-header>
        Employee
    </template>
    <template #createdBy="{ createdBy }" v-html="createdBy"></template>
</DataGrid>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useFormatters } from '@servicestack/vue'
import { bookings } from '../data'
import { Booking } from '../dtos'

const { currency } = useFormatters()
const selected = ref()

function headerSelected(column:string) {
    console.log('headerSelected',column)
}
function rowSelected(row:Booking) {
    selected.value = selected.value === row.id ? null : row.id
    console.log('rowSelected', row)
}
</script>
```

<responsive class="not-prose mb-4"></responsive>

Behavior of the DataGrid can be customized with the `@header-selected` event to handle when column headers are selected to 
apply custom filtering to the **items** data source whilst the `@row-selected` event can be used to apply custom behavior 
when a row is selected.

## Using Formatters

Your App and custom templates can also utilize @servicestack/vue's [built-in formatting functions](/vue/use-formatters) from:

```js
import { useFormatters } from '@servicestack/vue'

const {
    Formats,             // Available format methods to use in <PreviewFormat />
    formatValue,         // Format any value or object graph
    currency,            // Format number as Currency
    bytes,               // Format number in human readable disk size
    link,                // Format URL as <a> link
    linkTel,             // Format Phone Number as <a> tel: link
    linkMailTo,          // Format email as <a> mailto: link
    icon,                // Format Image URL as an Icon
    iconRounded,         // Format Image URL as a full rounded Icon
    attachment,          // Format File attachment URL as an Attachment
    hidden,              // Format as empty string
    time,                // Format duration in time format
    relativeTime,        // Format Date as Relative Time from now
    relativeTimeFromMs,  // Format time in ms as Relative Time from now
    formatDate,          // Format as Date
    formatNumber,        // Format as Number
} = useFormatters()
```

Many of these formatting functions return rich HTML markup which will need to be rendered using Vue's **v-html** directive:

```html
<span v-html="formatValue(value)"></span>
```

The [PreviewFormat](/vue/formats) component also offers a variety of flexible formatting options.

## Table Styles

The appearance of DataGrids can use **tableStyles** to change to different
[Tailwind Table Styles](https://tailwindui.com/components/application-ui/lists/tables), e.g:

### Default (Striped Rows)

```html
<DataGrid :items="tracks" />
```

<div class="not-prose">
<data-grid :items="tracks"></data-grid>
</div>

### Simple

```html
<DataGrid :items="tracks" table-style="simple" />
```

<div class="not-prose">
<data-grid :items="tracks" table-style="simple"></data-grid>
</div>

### Uppercase Headings

```html
<DataGrid :items="tracks" table-style="uppercaseHeadings" />
```

<div class="not-prose">
<data-grid :items="tracks" table-style="uppercaseHeadings"></data-grid>
</div>

### Vertical Lines

```html
<DataGrid :items="tracks" table-style="verticalLines" />
```

<div class="not-prose">
<data-grid :items="tracks" table-style="verticalLines"></data-grid>
</div>

### White Background

```html
<DataGrid :items="tracks" table-style="whiteBackground" />
```

<div class="not-prose">
<data-grid :items="tracks" table-style="whiteBackground"></data-grid>
</div>

### Full Width

```html
<DataGrid :items="tracks" table-style="fullWidth" />
```

<div class="not-prose">
<data-grid :items="tracks" table-style="fullWidth"></data-grid>
</div>

### Full Width, Uppercase with Vertical Lines

```html
<DataGrid :items="tracks" :table-style="['uppercaseHeadings', 'fullWidth', 'verticalLines']" />
```

<div class="not-prose">
<data-grid :items="tracks" :table-style="['uppercaseHeadings', 'fullWidth', 'verticalLines']"></data-grid>
</div>

## Using App Metadata

By default DataGrid will render values using its default configured formatters, so results with strings, numbers and defaults
will display a stock standard resultset:

```html
<DataGrid :items="bookings" />
```
<div class="not-prose prose-table">
<data-grid :items="bookings" class="mb-4"></data-grid>
</div>

Another option for formatting this dataset is to use the rich [format functions](/locode/formatters) in ServiceStack
to annotate the DTOs with how each field should be formatted, e.g:

```csharp
public class Booking
{
    [AutoIncrement]
    public int Id { get; set; }
    public string Name { get; set; }
    public RoomType RoomType { get; set; }
    public int RoomNumber { get; set; }

    [IntlDateTime(DateStyle.Long)]
    public DateTime BookingStartDate { get; set; }

    [IntlRelativeTime]
    public DateTime? BookingEndDate { get; set; }

    [IntlNumber(Currency = NumberCurrency.USD)]
    public decimal Cost { get; set; }
}
```

Which can be enabled when using [useMetadata](/vue/use-metadata) by specifying the `MetadataType` for the DataGrid's results in **type**:

```html
<DataGrid :items="bookings" type="Booking" />
```

<div class="not-prose prose-table">
<data-grid :items="bookings" type="Booking" class="mb-4"></data-grid>
</div>

Declaratively annotating your DTOs with preferred formatting hints makes this rich metadata information available to clients where
it's used to enhance ServiceStack's built-in UI's and Components like:

 - [API Explorer](/api-explorer)
 - [Locode](https://docs.servicestack.net/locode/)
 - [Blazor Tailwind Components](/templates/blazor-components)


# Auto Form Components
Source: https://razor-press.web-templates.io/vue/autoform

<api-reference Component="AutoForm"></api-reference>
## AutoForm

The `AutoForm` component is a generic form component that can be used to create and wire a traditional Form for any Request DTO definition
where successful responses can be handled the `@success` event, e.g:

```html
<AutoForm type="QueryBookings" @success="onSuccess" />
<div v-if="results">
    <h3 class="py-4 text-2xl">Results</h3>
    <HtmlFormat :value="results" />
</div>

<script setup>
const results = ref([])
const onSuccess = response => results.value = response.results
</script>
```

<div class="py-8 not-prose">
    <auto-form class="mx-auto max-w-3xl" type="QueryBookings" @success="onSuccess"></auto-form>
    <div v-if="results">
        <h3 class="py-4 text-2xl">Results</h3>
        <html-format :value="results"></html-format>
    </div>
</div>

These Auto Form components are customizable with the [declarative C# UI Attributes](/locode/declarative#ui-metadata-attributes) where you can 
override the form's **heading** with `[Description]` and include a **subHeading** with `[Notes]` which supports rich HTML markup.

**AutoForm Properties**

Alternatively they can be specified in the components properties:

```ts
defineProps<{
    type: string|InstanceType<any>|Function
    modelValue?: ApiRequest|any
    heading?: string
    subHeading?: string
    showLoading?: boolean
    jsconfig?: string         //= eccn,edv
    configureField?: (field:InputProp) => void

    /* Default Styles */
    formClass?: string        //= shadow sm:rounded-md
    innerFormClass?: string
    bodyClass?: string
    headerClass?: string      //= p-6
    buttonsClass?: string     //= mt-4 px-4 py-3 bg-gray-50 dark:bg-gray-900 sm:px-6 flex justify-between
    headingClass?: string     //= text-lg font-medium leading-6 text-gray-900 dark:text-gray-100
    subHeadingClass?: string
    submitLabel?: string      //= Submit
}>()
```

Both `@success` and `@error` events are fired after each API call, although built-in validation binding means it's typically unnecessary to manually 
handle error responses.

```ts
defineEmits<{
    (e:'success', response:any): void
    (e:'error', error:ResponseStatus): void
    (e:'update:modelValue', model:any): void
}>()
```

**Model Binding**

Forms can be bound to a Request DTO model where it can be used to pre-populate the Forms default values and Request DTO whereby specifying a **type** 
is no longer necessary:

```ts
<AutoForm v-model="request" />

<script setup>
const request = ref(new QueryBookings({ skip:1, take:2, orderBy:'Name' }))
</script>
```

<div class="not-prose">
    <auto-form class="mx-auto max-w-3xl not-prose" v-model="request" type="QueryBookings"></auto-form>
</div>

<api-reference Component="AutoCreateForm"></api-reference>
## Create Form

`AutoCreateForm` can be used to create an automated form based on a [AutoQuery CRUD](/autoquery/crud) Create Request DTO definition which can be rendered in a traditional inline Form with **card** formStyle option, e.g:

```html
<AutoCreateForm type="CreateBooking" formStyle="card" />
```

<div class="not-prose py-8">
    <auto-create-form class="mx-auto max-w-3xl" type="CreateBooking" form-style="card"></auto-create-form>
</div>

By default Auto Forms are rendered in a `SlideOver` dialog:

```html
<AutoCreateForm type="CreateBooking" />
```

<iframe src="/pages/vue/autoform/new.html" class="border-none h-[45em] w-[1330px] -ml-40 mb-4 relative z-20"></iframe>

These Auto Forms are powered by the rich [App Metadata](/vue/use-metadata) surrounding your APIs,
which contain all the necessary metadata to invoke the API and bind any contextual validation errors adjacent to the invalid field inputs.

<api-reference id="edit-form" component="AutoEditForm"></api-reference>
## Edit Form

`AutoEditForm` can be used to render an automated form based on Update and Delete
[AutoQuery CRUD](/autoquery/crud) APIs which also makes use of **heading** and **sub-heading** customization options:

```html
<AutoEditForm v-model="booking" type="UpdateBooking" deleteType="DeleteBooking" 
    heading="Change an existing Room Booking" sub-heading="Manage reservations for MyApp hotels." />
```

<iframe src="/pages/vue/autoform/edit.html" class="border-none h-[46em] w-[1330px] -ml-40 mb-4 relative z-20"></iframe>

The same form rendered in a traditional inline form with a **card** formStyle with some more advanced
customization examples using rich markup in custom `<template #heading>` and `<template #sub-heading>` slots:

```html
<AutoEditForm v-model="booking" formStyle="card" type="UpdateBooking" deleteType="DeleteBooking">
  <template #heading>
    <h3 class="text-xl font-semibold text-green-600">Change an existing Room Booking</h3>
  </template>
  <template #sub-heading>
    <p>
      Here are some 
      <TextLink href="https://youtu.be/rSFiikDjGos">good tips on making room reservations 
        <Icon class='inline-block' icon="lucide:external-link" />
      </TextLink>
    </p>
  </template>
</AutoEditForm>
```

<div class="not-prose">
    <auto-edit-form class="mx-auto max-w-3xl mb-4" v-model="booking" form-style="card" type="UpdateBooking" deleteType="DeleteBooking">
        <template #heading>
            <h3 class="text-xl font-semibold text-green-600">Change an existing Room Booking</h3>
        </template>
        <template #sub-heading>
            <p>
                Here are some <text-link href="https://youtu.be/rSFiikDjGos">good tips on making room reservations 
                    <svg class="inline-block" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6m4-3h6v6m-11 5L21 3"/></svg>
                </text-link>
            </p>
        </template>
    </auto-edit-form>
</div>

The forms behavior and appearance is further customizable with the
[API annotation](/locode/declarative#annotate-apis), declarative [validation](/locode/declarative#type-validation-attributes)
and the custom [Field and Input](/locode/declarative#custom-fields-and-inputs) attributes, e.g:

```csharp
[Description("Update an existing Booking")]
[Notes("Find out how to create a <a href='https://youtu.be/rSFiikDjGos'>C# Bookings App from Scratch</a>")]
[Route("/booking/{Id}", "PATCH")]
[ValidateHasRole("Employee")]
[AutoApply(Behavior.AuditModify)]
public class UpdateBooking : IPatchDb<Booking>, IReturn<IdResponse>
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public RoomType? RoomType { get; set; }
    [ValidateGreaterThan(0)]
    public int? RoomNumber { get; set; }
    [ValidateGreaterThan(0)]
    public decimal? Cost { get; set; }
    public DateTime? BookingStartDate { get; set; }
    public DateTime? BookingEndDate { get; set; }
    [Input(Type = "textarea")]
    public string? Notes { get; set; }
    public string? CouponId { get; set; }
    public bool? Cancelled { get; set; }
}
```

Where they can be used to customize Auto Form's appearance from annotations on C# Server DTOs:

```html
<AutoEditForm v-model="booking" formStyle="card" type="UpdateBooking" deleteType="DeleteBooking" />
```

<div class="not-prose">
<auto-edit-form class="mx-auto max-w-3xl" v-model="booking" form-style="card" type="UpdateBooking" deleteType="DeleteBooking"></auto-edit-form>
</div>

<api-reference component="AutoFormFields"></api-reference>
## Form Fields

For more advanced customization of a Forms appearance and behavior, `AutoFormFields` can be used to just render the Form's fields (with validation binding) inside a custom Form which can submit the data-bound populated Request DTO to invoke the API, e.g:

```html
<template>
<form v-if="request" @submit.prevent="submit">
    <div class="shadow sm:overflow-hidden sm:rounded-md">
        <div class="space-y-6 py-6 px-4 sm:p-6 bg-white dark:bg-black">
            <div>
                <h3 class="text-lg font-medium leading-6 text-gray-900 dark:text-gray-100">
                    Change an existing Room Booking
                </h3>
                <p class="notes mt-1 text-sm text-gray-500 dark:text-gray-400">
                    Find out how to quickly create a 
                    <a class='svg-external' target='_blank' href='https://youtu.be/rSFiikDjGos'>
                        C# Bookings App from Scratch
                    </a>
                </p>
            </div>

            <AutoFormFields v-model="request" :api="api" />

        </div>
        <div class="bg-gray-50 dark:bg-gray-800 px-4 py-3 text-right sm:px-12">
            <PrimaryButton>Save</PrimaryButton>
        </div>
    </div>
</form>
</template>

<script setup lang="ts">
import { onMounted, ref } from 'vue'
import { ApiResponse } from '@servicestack/client'
import { useClient, useMetadata } from '@servicestack/vue'
import { QueryBookings, UpdateBooking } from '../dtos'

const { toFormValues } = useMetadata()
const client = useClient()

let api = ref<ApiResponse>()
let request = ref<UpdateBooking>()

async function submit(e:Event) {
    api.value = await client.api(request.value!)
}

onMounted(async () => {
    let api = await client.api(new QueryBookings({ id: 1 }))
    if (api.succeeded) {
        request.value = new UpdateBooking(toFormValues(api.response!.results[0]))
    }
})
</script>
```

<div class="not-prose">
    <fields class="my-4 mx-auto max-w-screen-md"></fields>
</div>

`toFormValues` is used when updating the data bound `request` DTO to convert API response values into the required format that HTML Inputs expect.


# Form Inputs Components
Source: https://razor-press.web-templates.io/vue/form-inputs

<api-reference component="TextInput"></api-reference>
## Bookings Form

The `TextInput`, `SelectInput`, `CheckboxInput` and `TextAreaInput` contains the most popular
Input controls used by C# POCOs which can be bound directly to Request DTOs and includes support for
[declarative](/declarative-validation) and [Fluent Validation](/validation) binding.

```html
<form @submit.prevent="submit">
    <div class="shadow sm:overflow-hidden sm:rounded-md">
        <div class="space-y-6 py-6 px-4 sm:p-6 bg-white dark:bg-black">
            <div>
                <h3 class="text-lg font-medium leading-6 text-gray-900 dark:text-gray-100">
                    Update an existing Booking
                </h3>
            </div>
            <fieldset>
                <ErrorSummary :except="visibleFields" class="mb-4" />
                <div class="grid grid-cols-6 gap-6">
                    <div class="col-span-6 sm:col-span-3">
                        <TextInput id="name" v-model="request.name" required placeholder="Name for this booking" />
                    </div>
                    <div class="col-span-6 sm:col-span-3">
                        <SelectInput id="roomType" v-model="request.roomType" :options="enumOptions('RoomType')" />
                    </div>
                    <div class="col-span-6 sm:col-span-3">
                        <TextInput type="number" id="roomNumber" v-model="request.roomNumber" min="0" required />
                    </div>
                    <div class="col-span-6 sm:col-span-3">
                        <TextInput type="number" id="cost" v-model="request.cost" min="0" required />
                    </div>
                    <div class="col-span-6 sm:col-span-3">
                        <TextInput type="date" id="bookingStartDate" v-model="request.bookingStartDate" required />
                    </div>
                    <div class="col-span-6 sm:col-span-3">
                        <TextInput type="date" id="bookingEndDate" v-model="request.bookingEndDate" />
                    </div>
                    <div class="col-span-6">
                        <TextareaInput id="notes" v-model="request.notes" placeholder="Notes about this booking" class="h-24" />
                    </div>
                </div>
            </fieldset>
        </div>
        <div class="mt-4 bg-gray-50 dark:bg-gray-800 px-4 py-3 text-right sm:px-12">
            <div class="flex justify-between space-x-3">
                <div>
                    <ConfirmDelete v-if="canDelete" @delete="onDelete">Delete</ConfirmDelete>
                </div>
                <div>
                    <PrimaryButton @click="submit">Update Booking</PrimaryButton>
                </div>
            </div>
        </div>
    </div>
</form>
```

<bookings-form :id="1" class="not-prose mb-4"></bookings-form>

Which can be wired up to handle querying, updating and deleting including limiting functionality to authorized users with:

```html
<script setup lang="ts">
import { computed, ref, watchEffect } from 'vue'
import { useMetadata, useAuth, useClient } from '@servicestack/vue'
import { DeleteBooking, QueryBookings, UpdateBooking } from '../dtos'

const props = defineProps<{
    id: number
}>()
const emit = defineEmits<{
    (e: 'done'): void
}>()

const { enumOptions, toFormValues } = useMetadata()

const visibleFields = "name,roomType,roomNumber,bookingStartDate,bookingEndDate,cost,notes"

const { hasRole, user, isAuthenticated } = useAuth()
const canDelete = computed(() => hasRole('Manager'))
const client = useClient()
const request = ref(new UpdateBooking())

watchEffect(async () => {
    const api = await client.api(new QueryBookings({ id: props.id }))
    if (api.succeeded) {
        request.value = new UpdateBooking(toFormValues(api.response?.results[0]))
    }
})

async function submit(e:Event) {
    const api = await client.api(request.value)
    if (api.succeeded) close()
}
async function onDelete() {
    const api = await client.apiVoid(new DeleteBooking({ id: props.id }))
    if (api.succeeded) close()
}

const close = () => emit('done')
</script>
```

This also shows how we can utilize `enumOptions` from our [App Metadata](/vue/use-metadata) to populate select drop downs from C# enums.


# FileInput Component
Source: https://razor-press.web-templates.io/vue/fileinput

The `<FileInput>` component beautifies the browsers default HTML file Input, supporting both Single file: 

```html
<FileInput id="profileUrl" label="Single File Upload" v-model="contact.profileUrl" />
```
<div class="not-prose">
<file-input id="profileUrl" label="Single File Upload" v-model="contact.profileUrl" class="max-w-lg mb-4"></file-input>
</div>

and Multiple File Uploads:

```html
<FileInput id="profileUrls" label="Multiple File Uploads" multiple :files="contact.files" />
```
<div class="not-prose">
<file-input id="profileUrls" label="Multiple File Uploads" multiple :files="files" class="max-w-lg not-prose mb-4"></file-input>
</div>

Use **files** when your binding to a `UploadedFile` complex type or **values** when binding to a `string[]` of file paths.
When binding to relative paths, absolute URLs are resolved using [assetsPathResolver](/vue/use-config).

## Invoking APIs containing uploaded files

When uploading files, you'll need to submit API requests using the `apiForm` or `apiFormVoid` methods to send
a populated `FormData` instead of a Request DTO, e.g:

```html
<form @submit.prevent="submit">
    <FileInput id="profileUrls" label="Multiple File Uploads" multiple :files="files" />
    <PrimaryButton>Save</PrimaryButton>
</form>

<script setup lang="ts">
import { useClient } from "@servicestack/vue"
import { CreateContact } from "/mjs/dtos.mjs"

const client = useClient()
async function submit(e:Event) {
    const form = e.target as HTMLFormElement
    const api = await client.apiForm(new CreateContact(), new FormData(form))
    if (api.succeeded) {
        //...
    }
}
</script>
```

## Integrates with Managed File Uploads

Using [Managed File Uploads](/locode/files-overview) is a productive solution for easily managing file uploads where you can declaratively specify
which location uploaded files should be written to, e.g:

```csharp
public class UpdateContact : IPatchDb<Contact>, IReturn<Contact>
{
    public int Id { get; set; }
    [ValidateNotEmpty]
    public string? FirstName { get; set; }
    [ValidateNotEmpty]
    public string? LastName { get; set; }
    [Input(Type = "file"), UploadTo("profiles")]
    public string? ProfileUrl { get; set; }
    public int? SalaryExpectation { get; set; }
    [ValidateNotEmpty]
    public string? JobType { get; set; }
    public int? AvailabilityWeeks { get; set; }
    public EmploymentType? PreferredWorkType { get; set; }
    public string? PreferredLocation { get; set; }
    [ValidateNotEmpty]
    public string? Email { get; set; }
    public string? Phone { get; set; }
    [Input(Type = "tag"), FieldCss(Field = "col-span-12")]
    public List<string>? Skills { get; set; }
    [Input(Type = "textarea")]
    [FieldCss(Field = "col-span-12 text-center", Input = "h-48", Label= "text-xl text-indigo-700")]
    public string? About { get; set; }
}
```

This metadata information is also available to [AutoForm components](/vue/autoform) which supports invoking APIs with uploaded files:

```html
<AutoEditForm type="UpdateContact" v-model="contact" formStyle="card" />
```
<div class="not-prose">
<auto-edit-form id="updatecontact" data-id="UpdateContact" type="UpdateContact" v-model="contact" form-style="card" class="not-prose max-w-3xl"></auto-edit-form>
</div>


# TagInput Component
Source: https://razor-press.web-templates.io/vue/taginput

The `TagInput` component provides a user friendly control for managing a free-form `List<string>` tags or symbols
which is also supported in declarative Auto Forms using the `[Input(Type="tag")]` attribute as seen in the 
**UpdateContact** example using the [AutoForm components](/vue/autoform):

```html
<AutoEditForm type="UpdateContact" v-model="contact" formStyle="card" />
```
<auto-edit-form id="updatecontact" data-id="UpdateContact" type="UpdateContact" v-model="contact" form-style="card" class="not-prose max-w-3xl mb-4"></auto-edit-form>

Generated from the **UpdateContact** C# Request DTO:

```csharp
public class UpdateContact : IPatchDb<Contact>, IReturn<Contact>
{
    public int Id { get; set; }
    [ValidateNotEmpty]
    public string? FirstName { get; set; }
    [ValidateNotEmpty]
    public string? LastName { get; set; }
    [Input(Type = "file"), UploadTo("profiles")]
    public string? ProfileUrl { get; set; }
    public int? SalaryExpectation { get; set; }
    [ValidateNotEmpty]
    public string? JobType { get; set; }
    public int? AvailabilityWeeks { get; set; }
    public EmploymentType? PreferredWorkType { get; set; }
    public string? PreferredLocation { get; set; }
    [ValidateNotEmpty]
    public string? Email { get; set; }
    public string? Phone { get; set; }
    [Input(Type = "tag"), FieldCss(Field = "col-span-12")]
    public List<string>? Skills { get; set; }
    [Input(Type = "textarea")]
    [FieldCss(Field = "col-span-12 text-center", Input = "h-48", Label= "text-xl text-indigo-700")]
    public string? About { get; set; }
}
```

Alternatively `<TagInput>` can be used in Custom Forms directly by binding to a `List<string>` or `string[]` model:

<api-reference component="TagInput"></api-reference>
## Custom Form

```html
<form @submit.prevent="submit">
    <div class="shadow sm:rounded-md bg-white dark:bg-black">
        <div class="relative px-4 py-5 sm:p-6">
            <fieldset>
                <legend class="text-base font-medium text-gray-900 dark:text-gray-100 text-center mb-4">
                    TagInput Examples
                </legend>
                <ErrorSummary :except="visibleFields" />
                <div class="grid grid-cols-12 gap-6">
                    <div class="col-span-6">
                        <TextInput v-model="request.firstName" />
                    </div>
                    <div class="col-span-6">
                        <TextInput v-model="request.lastName" />
                    </div>
                    <div class="col-span-12">
                        <TagInput v-model="request.skills" label="Technology Skills" 
                            :allowableValues="['c#','servicestack','vue','.net','typescript']" />
                    </div>
                </div>
            </fieldset>
        </div>
        <div class="mt-4 px-4 py-3 bg-gray-50 dark:bg-gray-900 sm:px-6 flex flex-wrap justify-between">
            <div></div>
            <div class="flex justify-end">
                <SecondaryButton class="mr-4">Cancel</SecondaryButton>
                <PrimaryButton type="submit">Submit</PrimaryButton>
            </div>
        </div>
    </div>
</form>
```

<form data-id="TagInputExamples" class="max-w-screen-md not-prose" @submit.prevent="submit">
    <div class="shadow sm:rounded-md bg-white dark:bg-black">
        <div class="relative px-4 py-5 sm:p-6">
            <fieldset>
                <legend class="text-base font-medium text-gray-900 dark:text-gray-100 text-center mb-4">
                    TagInput Examples
                </legend>
                <error-summary :except="visibleFields"></error-summary>
                <div class="grid grid-cols-12 gap-6">
                    <div class="col-span-6">
                        <text-input v-model="request.firstName"></text-input>
                    </div>
                    <div class="col-span-6">
                        <text-input v-model="request.lastName"></text-input>
                    </div>
                    <div class="col-span-12">
                        <tag-input v-model="request.skills" label="Technology Skills"
                            :allowable-values="['c#','servicestack','vue','.net','typescript']"></tag-input>
                    </div>
                </div>
            </fieldset>
        </div>
        <div class="mt-4 px-4 py-3 bg-gray-50 dark:bg-gray-900 sm:px-6 flex flex-wrap justify-between">
            <div></div>
            <div class="flex justify-end">
                <secondary-button class="mr-4">Cancel</secondary-button>
                <primary-button type="submit">Submit</primary-button>
            </div>
        </div>
    </div>
</form>


<api-reference component="TagInput"></api-reference>
## Allowable Values

The list of allowable values can also be populated on C# Request DTO from a JavaScript expression:

```csharp
public class MyRequest
{
    [Input(Type = "tag", Options="{ allowableValues: ['c#','servicestack','vue'] }")]
    public List<string>? Skills { get; set; }
}
```

Or from a [#Script Expression](https://sharpscript.net) in `EvalEvalAllowableValues` where it can be populated from a static list, e.g:

```csharp
public class MyRequest
{
    [Input(Type = "tag", EvalEvalAllowableValues="['c#','servicestack','vue']")]
    public List<string>? Skills { get; set; }
}
```

Or sourced from a C# Expression, e.g:

```csharp
public class MyRequest
{
    [Input(Type = "tag", EvalEvalAllowableValues="AppData.Tags")]
    public List<string>? Skills { get; set; }
}
```

Where it can be populated from a dynamic data source like from an RDBMS populated in your AppHost on Startup, e.g:

```csharp
ScriptContext.Args[nameof(AppData)] = new AppData {
    Tags = db.Select<Tag>().Select(x => x.Name).ToList()
};
```


# Combobox Component
Source: https://razor-press.web-templates.io/vue/combobox

The `Combobox` component provides an Autocomplete Input optimized for searching a List of string values, Key Value Pairs or Object Dictionary, e.g:

```html
<div class="grid grid-cols-12 gap-6">
  <Combobox id="Strings" class="col-span-4" v-model="strings" :values="['Alpha','Bravo','Charlie']" />
  <Combobox id="Object"  class="col-span-4" v-model="objects" :options="{ A:'Alpha', B:'Bravo', C:'Charlie' }" />
  <Combobox id="Pairs"   class="col-span-4" v-model="pairs"   label="Multiple from Pairs" multiple
    :entries="[{key:'A',value:'Alpha'}, {key:'B',value:'Bravo'}, {key:'C',value:'Charlie'}]" />
</div>
```

<div class="not-prose grid grid-cols-12 gap-6">
  <combobox id="Strings" class="col-span-4" v-model="strings" :values="['Alpha','Bravo','Charlie']"></combobox>
  <combobox id="Object"  class="col-span-4" v-model="objects" :options="{ A:'Alpha', B:'Bravo', C:'Charlie' }"></combobox>
  <combobox id="Pairs"   class="col-span-4" v-model="pairs"   label="Multiple from Pairs" multiple
    :entries="[{key:'A',value:'Alpha'}, {key:'B',value:'Bravo'}, {key:'C',value:'Charlie'}]"></combobox>
</div>

Which supports populating both a single string value or multiple strings in an Array with **multiple** property.

<api-reference component="Combobox"></api-reference>
## Auto Forms

Combobox components can also be used in [Auto Form Components](/vue/autoform) on `string` or string collection properties
with the `[Input(Type="combobox")]` [declarative UI Attribute](/locode/declarative#ui-metadata-attributes) on C# Request DTOs, e.g:

```csharp
public class ComboBoxExamples : IReturn<ComboBoxExamples>, IPost
{
    [Input(Type="combobox", Options = "{ allowableValues:['Alpha','Bravo','Charlie'] }")]
    public string? SingleClientValues { get; set; }

    [Input(Type="combobox", Options = "{ allowableValues:['Alpha','Bravo','Charlie'] }", Multiple = true)]
    public List<string>? MultipleClientValues { get; set; }

    [Input(Type="combobox", EvalAllowableValues = "['Alpha','Bravo','Charlie']")]
    public string? SingleServerValues { get; set; }

    [Input(Type="combobox", EvalAllowableValues = "AppData.AlphaValues", Multiple = true)]
    public List<string>? MultipleServerValues { get; set; }

    [Input(Type="combobox", EvalAllowableEntries = "{ A:'Alpha', B:'Bravo', C:'Charlie' }")]
    public string? SingleServerEntries { get; set; }

    [Input(Type="combobox", EvalAllowableEntries = "AppData.AlphaDictionary", Multiple = true)]
    public List<string>? MultipleServerEntries { get; set; }
}
```

Which can then be rendered with:

```html
<AutoForm type="ComboBoxExamples" />
```
<auto-form type="ComboBoxExamples" class="not-prose mb-4"></auto-form>

**Combobox Options**

Each property shows a different way of populating the Combobox's optional values, they can be populated from a JavaScript
Object literal using `Options` or on the server with a [#Script Expression](https://sharpscript.net) where they can be 
populated from a static list or from a C# class as seen in the examples referencing `AppData` properties:

```csharp
public class AppData
{
    public List<string> AlphaValues { get; set; }
    public Dictionary<string, string> AlphaDictionary { get; set; }
    public List<KeyValuePair<string, string>> AlphaKeyValuePairs { get; set; }
}
```

Which are populated on in the AppHost on Startup with:

```csharp
ScriptContext.Args[nameof(AppData)] = new AppData
{
    AlphaValues = new() {
        "Alpha", "Bravo", "Charlie"
    },
    AlphaDictionary = new()
    {
        ["A"] = "Alpha",
        ["B"] = "Bravo",
        ["C"] = "Charlie",
    },
    AlphaKeyValuePairs = new()
    {
        new("A","Alpha"),
        new("B","Bravo"),
        new("C","Charlie"),
    },
};
```

Which can alternatively be populated from a dynamic source like an RDBMS table.

As C# Dictionaries have an undetermined sort order, you can use a `List<KeyValuePair<string, string>>` instead when you need to
display an ordered list of Key/Value pairs.


# Autocomplete Component
Source: https://razor-press.web-templates.io/vue/autocomplete

The `Autocomplete` component provides a user friendly Input for being able to search and quickly select items
with support for partial items view and infinite scrolling.

```html
<form class="col-span-12">
    <div class="mb-3">
        <Autocomplete id="simple" :options="allContacts" v-model="simple" label="Single Contact"
            :match="(x: any, value: string) => x!.displayName.toLowerCase().includes(value.toLowerCase())"
            placeholder="Select Contact">
            <template #item="{ displayName }">
                <span class="block truncate">{{ displayName }}</span>
            </template>
        </Autocomplete>
        <div class="mt-2 flex justify-end">
            <p>
                <b class="text-gray-500">Single:</b>
                <div v-if="simple" class="flex">
                    <img :src="simple.profileUrl" class="w-8 h-8 rounded-full mr-2">
                    <b class="text-lg">{{ simple.displayName }}</b>
                </div>
            </p>
        </div>
    </div>

    <div class="mb-3">
        <Autocomplete id="contact" :options="allContacts" v-model="contact" label="Single Contact with Icon"
            :match="(x: any, value: string) => x!.displayName.toLowerCase().includes(value.toLowerCase())"
            placeholder="Select Contact">
            <template #item="{ displayName, profileUrl }">
                <div class="flex items-center">
                    <Icon class="h-6 w-6 flex-shrink-0 rounded-full" :src="profileUrl" loading="lazy" />
                    <span class="ml-3 truncate">{{ displayName }}</span>
                </div>
            </template>
        </Autocomplete>
        <div class="mt-2 flex justify-end">
            <p>
                <b class="text-gray-500">Single with Icon:</b>
                <div v-if="contact" class="flex">
                    <img :src="contact.profileUrl" class="w-8 h-8 rounded-full mr-2">
                    <b class="text-lg">{{ contact.displayName }}</b>
                </div>
            </p>
        </div>
    </div>

    <div class="mb-3">
        <Autocomplete id="contacts" :options="allContacts" v-model="contacts" multiple
            label="Multiple Contacts with Icon"
            :match="(x: any, value: string) => x!.displayName.toLowerCase().includes(value.toLowerCase())"
            placeholder="Select Contact">
            <template #item="{ displayName, profileUrl }">
                <div class="flex items-center">
                    <Icon class="h-6 w-6 flex-shrink-0 rounded-full" :src="profileUrl" loading="lazy" />
                    <span class="ml-3 truncate">{{ displayName }}</span>
                </div>
            </template>
        </Autocomplete>
        <div class="mt-2">
            <div class="text-right"><b class="text-gray-500">Multiple with Icon:</b></div>
            <p>
            <div v-if="contacts.length" class="flex flex-wrap">
                <div v-for="contact in contacts" class="flex ml-4 mb-2">
                    <img :src="contact.profileUrl" class="w-6 h-6 rounded-full mr-2">
                    <span>{{ contact.displayName }}</span>
                </div>
            </div>
            </p>
        </div>
    </div>
</form>
```

## Custom Form

<div class="not-prose">
<autocomplete-examples class="max-w-prose"></autocomplete-examples>
</div>


# Modal Components
Source: https://razor-press.web-templates.io/vue/modals

<api-reference component="ModalDialog"></api-reference>
## ModalDialog

Use `<ModalDialog>` component to show any content inside a Modal Dialog:

```html
<SecondaryButton @click="showDialog=true">Show Modal</SecondaryButton>
<ModalDialog v-if="showDialog" @done="showDialog=false">
  <h3 class="p-8 text-3xl">Hello @servicestack/vue!</h3>
</ModalDialog>
```

<div class="not-prose">
    <secondary-button @click="showDialog=true">Show Modal</secondary-button>
    <modal-dialog v-if="showDialog" @done="showDialog=false"><h3 class="p-8 text-3xl">Hello @servicestack/vue!</h3></modal-dialog>
</div>

<api-reference component="SlideOver"></api-reference>
## SlideOver

Use `<SlideOver>` to show contents inside an animated slide over:

```html
<SecondaryButton @click="showSlide=true" class="mt-4">Show Slide</SecondaryButton>
<SlideOver v-if="showSlide" title="The Title" @done="showSlide=false" content-class="relative flex-1">
  <template #subtitle>
    a <b>subtitle</b>
  </template>
  <Alert type="error">Authentication Required</Alert>
  <div class="md:p-4">
    <SecondaryButton>Sign In</SecondaryButton>
  </div>
</SlideOver>
```

<div class="not-prose">
    <secondary-button @click="showSlide=true" class="mt-4">Show Slide</secondary-button>
    <slide-over v-if="showSlide" title="The Title" @done="showSlide=false" content-class="relative flex-1">
        <template #subtitle>
            a <b>subtitle</b>
        </template>
        <alert type="error">Authentication Required</alert>
        <div class="md:p-4">
            <secondary-button>Sign In</secondary-button>
        </div>
    </slide-over>
</div>


As seen in this example we can use **content-class** to customize the inner body contents and the `<template #subtitle>` slot
to include an optional rich HTML subtitle, with all other inner contents is displayed in the SlideOver's body.

<api-reference component="SignIn"></api-reference>
## SignIn

The `<SignIn>` Component can be used to create an instant Sign Up form based on the [registered Auth Providers](/auth/) that handles
Signing In authenticated users into Vue Apps with the [useAuth()](/vue/use-auth) APIs:


```html
<SignIn v-if="!user" />
<h3 v-else class="text-2xl my-4">Hello, {{ user.displayName }}</h3>

<script setup>
import { useAuth } from "@servicestack/vue"
const { user } = useAuth()
</script>
```

<div class="not-prose">
    <sign-in v-if="!user" :tabs="false"></sign-in>
    <h3 v-else class="text-2xl my-4">Hello, {{ user.displayName }}</h3>
</div>

**SignIn Properties**

```ts
defineProps<{
    provider?: string  // which Auth Provider to default to
    title?: string     //= Sign In - Heading
    tabs?: boolean     //= true - Show different Auth Provider tabs
    oauth?: boolean    //= true - Show OAuth Provider buttons
}>()
```

**Events**

Use `@login` to run custom logic after successful authentication:

```ts
defineEmits<{
    (e:'login', auth:AuthenticateResponse): void
}>()
```


# Navigation Components
Source: https://razor-press.web-templates.io/vue/navigation

<api-reference component="Tabs"></api-reference>
## Tabs

The `<Tabs>` component lets you switch between different Vue components from a object component dictionary where the **Key** is used for the Tab's label and URL param and the **Value** component for the tab body. 

```html
<script setup>
import A from "./A.vue"
import B from "./B.vue"
import C from "./C.vue"
const tabs = { A, B, C }
</script>
```

The Tab's Label can alternatively be overridden with a custom **label** function, e.g:

```html
<Tabs :tabs="tabs" :label="tab => `${tab} Tab Label`" />
```
<tabs :tabs="tabs" :label="tab => `${tab} Tab Label`" class="not-prose mb-8"></tabs>

**Tabs properties**

```ts
defineProps<{
    tabs: {[name:string]:Component }
    id?: string                      //= tabs
    param?: string                   //= tab - URL param to use
    label?: (tab:string) => string   // - Custom function to resolve Tab Label
    selected?: string                // - The selected tab
    tabClass?: string                // - Additional classes for Tab Label
    bodyClass?: string               // - Classes for Tab Body
    url?:boolean                     //= true - Whether to maintain active tab in history.pushState()
}>()
```

<api-reference component="Breadcrumbs"></api-reference>
## Breadcrumbs

Breadcrumb example:

```html
<Breadcrumbs home-href="/vue/">
  <Breadcrumb href="/vue/gallery">gallery</Breadcrumb>
  <Breadcrumb>Navigation Examples</Breadcrumb>
</Breadcrumbs>
```

<Breadcrumbs class="not-prose my-8" home-href="/vue/">
  <Breadcrumb href="/vue#gallery">gallery</Breadcrumb>
  <Breadcrumb>Navigation Examples</Breadcrumb>
</Breadcrumbs>

<api-reference component="NavList"></api-reference>
## NavList

Use `NavList` for rendering a vertical navigation list with Icons:

```html
<NavList title="Explore Vue Tailwind Components">
    <NavListItem title="DataGrid" href="/vue/gallery/datagrid" :iconSvg="Icons.DataGrid">
        DataGrid Component Examples for rendering tabular data
    </NavListItem>
    <NavListItem title="AutoQuery Grid" href="/vue/gallery/autoquerygrid" :iconSvg="Icons.AutoQueryGrid">
        Instant customizable UIs for calling AutoQuery CRUD APIs
    </NavListItem>
</NavList>
```

<div class="my-8 not-prose">
    <nav-list-examples class="max-w-3xl mx-auto"></nav-list-examples>
</div>

<api-reference component="PrimaryButton"></api-reference>
## Link Buttons

Using `href` with Button components will style hyper links to behave like buttons:

```html
<PrimaryButton href="https://vue-mjs.web-templates.io/" class="mr-2">
    Vue.mjs Template
</PrimaryButton>

<SecondaryButton href="/vue/">
    Vue Component Docs
</SecondaryButton>
```

<div class="my-8 not-prose">
    <primary-button href="https://vue-mjs.web-templates.io/" class="mr-2">Vue.mjs Template</primary-button>
    <secondary-button href="/vue/">Vue Component Docs</secondary-button>
</div>

<api-reference component="PrimaryButton"></api-reference>
## PrimaryButton

That can use **color** to render it in different colors:

```html
<PrimaryButton>Default</PrimaryButton>
<PrimaryButton color="blue">Blue</PrimaryButton>
<PrimaryButton color="purple">Purple</PrimaryButton>
<PrimaryButton color="red">Red</PrimaryButton>
<PrimaryButton color="green">Green</PrimaryButton>
<PrimaryButton color="sky">Sky</PrimaryButton>
<PrimaryButton color="cyan">Cyan</PrimaryButton>
<PrimaryButton color="indigo">Indigo</PrimaryButton>
```

<div class="my-8 not-prose space-x-2">
    <primary-button>Default</primary-button>
    <primary-button color="blue">Blue</primary-button>
    <primary-button color="purple">Purple</primary-button>
    <primary-button color="red">Red</primary-button>
    <primary-button color="green">Green</primary-button>
    <primary-button color="sky">Sky</primary-button>
    <primary-button color="cyan">Cyan</primary-button>
    <primary-button color="indigo">Indigo</primary-button>
</div>

<api-reference component="TextLink"></api-reference>
## TextLink

Tailwind `<a>` hyper links, e.g:

```html
<TextLink href="/vue/" class="text-xl">
    docs.servicestack.net/vue
</TextLink>
```

<div class="not-prose">
<text-link href="/vue/" class="text-xl">docs.servicestack.net/vue</text-link>
</div>

That can also use **color** to render it in different colors:

```html
<TextLink @click="say('Hi!')" title="Greetings">Default <b>Link</b></TextLink>
<TextLink color="purple" href="https://google.com" target="_blank" title="Google Link">Purple <b>Link</b></TextLink>
<TextLink color="red"    href="https://google.com" target="_blank" title="Google Link">Red <b>Link</b></TextLink>
<TextLink color="green"  href="https://google.com" target="_blank" title="Google Link">Green <b>Link</b></TextLink>
<TextLink color="sky"    href="https://google.com" target="_blank" title="Google Link">Sky <b>Link</b></TextLink>
<TextLink color="cyan"   href="https://google.com" target="_blank" title="Google Link">Cyan <b>Link</b></TextLink>
<TextLink color="indigo" href="https://google.com" target="_blank" title="Google Link">Indigo <b>Link</b></TextLink>
```

<div class="not-prose flex space-x-4">
  <text-link @click="say('Hi!')" title="Greetings">Default <b>Link</b></text-link>
  <text-link color="purple" href="https://google.com" target="_blank" title="Google Link">Purple <b>Link</b></text-link>
  <text-link color="red"    href="https://google.com" target="_blank" title="Google Link">Red <b>Link</b></text-link>
  <text-link color="green"  href="https://google.com" target="_blank" title="Google Link">Green <b>Link</b></text-link>
  <text-link color="sky"    href="https://google.com" target="_blank" title="Google Link">Sky <b>Link</b></text-link>
  <text-link color="cyan"   href="https://google.com" target="_blank" title="Google Link">Cyan <b>Link</b></text-link>
  <text-link color="indigo" href="https://google.com" target="_blank" title="Google Link">Indigo <b>Link</b></text-link>
</div>


# Alert Components
Source: https://razor-press.web-templates.io/vue/alerts

<api-reference component="Alert"></api-reference>
## Alert

<p class="mb-4 text-lg">
    Show basic alert message:
</p>

```html
<Alert>Default <b>Message</b></Alert>
<Alert type="info">Information <b>Message</b></Alert>
<Alert type="success">Success <b>Message</b></Alert>
<Alert type="warn">Warning <b>Message</b></Alert>
<Alert type="error">Error <b>Message</b></Alert>
```

<div class="not-prose mb-4">
<alert>Default <b>Message</b></alert>
<alert type="info">Information <b>Message</b></alert>
<alert type="success">Success <b>Message</b></alert>
<alert type="warn">Warning <b>Message</b></alert>
<alert type="error">Error <b>Message</b></alert>
</div>

Show alert message from dynamic HTML string:

```html
<Alert v-html="message" />

<script>
const message = "Requires <b>Employee</b> Role"
</script>
```

<div class="not-prose">
<alert v-html="message"></alert>
</div>

<api-reference component="AlertSuccess"></api-reference>
## Alert Success

Show success alert message:

```html
<AlertSuccess>Order was received</AlertSuccess>
```

<div class="not-prose">
<alert-success class="not-prose">Order was received</alert-success>
</div>

<api-reference component="ErrorSummary"></api-reference>
## Error Summary

Show failed Summary API Error Message:

```html
<ErrorSummary :status="{ message:'Requires Employee Role' }" />
```

<div class="not-prose">
<error-summary :status="{ message:'Requires Employee Role' }" class="not-prose"></error-summary>
</div>


# Format Examples
Source: https://razor-press.web-templates.io/vue/formats

<api-reference component="PreviewFormat"></api-reference>
## PreviewFormat

Useful for rendering Table Cell data into different customizable formats, e.g:

### Currency

```html
<PreviewFormat :value="50" :format="Formats.currency" />
```
<div class="not-prose">
<preview-format :value="50" :format="Formats.currency"></preview-format>
</div>

### Bytes

```html
<PreviewFormat :value="10000000" :format="Formats.bytes" />
```
<div class="not-prose">
<preview-format :value="10000000" :format="Formats.bytes"></preview-format>
</div>

### Icon

```html
<PreviewFormat value="/pages/vue/1.jpg" :format="Formats.icon" />
```
<div class="not-prose">
<preview-format value="/pages/vue/1.jpg" :format="Formats.icon"></preview-format>
</div>

### Icon Rounded

```html
<PreviewFormat value="/pages/vue/1.jpg" :format="Formats.iconRounded" />
```
<div class="not-prose">
<preview-format value="/pages/vue/1.jpg" :format="Formats.iconRounded"></preview-format>
</div>

### Icon with custom class

```html
<PreviewFormat value="/pages/vue/1.jpg" :format="Formats.icon" class="w-40 h-40 rounded-full" />
```
<div class="not-prose">
<preview-format value="/pages/vue/1.jpg" :format="Formats.icon" class="not-prose w-40 h-40 rounded-full"></preview-format>
</div>

### Attachment (Image)

```html
<PreviewFormat value="/pages/vue/1.jpg" :format="Formats.attachment" />
```
<div class="not-prose">
<preview-format value="/pages/vue/1.jpg" :format="Formats.attachment"></preview-format>
</div>

### Attachment (Document)

```html
<PreviewFormat value="/content/hosting.md" :format="Formats.attachment" />
```
<div class="not-prose">
<preview-format value="/content/hosting.md" :format="Formats.attachment"></preview-format>
</div>

### Attachment (Document) with classes

```html
<PreviewFormat value="/content/hosting.md" :format="Formats.attachment" 
    class="text-xl text-indigo-700 font-semibold" icon-class="w-8 h-8" />
```
<div class="not-prose">
<preview-format value="/content/hosting.md" :format="Formats.attachment" class="text-xl text-indigo-700 font-semibold" icon-class="w-8 h-8"></preview-format>
</div>

### Link

```html
<PreviewFormat value="https://servicestack.net/blazor" :format="Formats.link" />
```
<div class="not-prose">
<preview-format value="https://servicestack.net/blazor" :format="Formats.link"></preview-format>
</div>

### Link with class

```html
<PreviewFormat value="https://servicestack.net/blazor" :format="Formats.link" class="text-xl" />
```
<div class="not-prose">
<preview-format value="https://servicestack.net/blazor" :format="Formats.link" class="text-xl text-blue-600"></preview-format>
</div>

### Link Email

```html
<PreviewFormat value="user@email.com" :format="Formats.linkMailTo" />
```
<div class="not-prose">
<preview-format value="user@email.com" :format="Formats.linkMailTo"></preview-format>
</div>

### Link Phone

```html
<PreviewFormat value="555 123 4567" :format="Formats.linkTel" />
```
<div class="not-prose">
<preview-format value="555 123 4567" :format="Formats.linkTel"></preview-format>
</div>

## Using Formatters

Your App and custom templates can also utilize @servicestack/vue's [built-in formatting functions](/vue/use-formatters) from:

```js
import { useFormatters } from '@servicestack/vue'

const {
    Formats,             // Available format methods to use in <PreviewFormat />
    formatValue,         // Format any value or object graph
    currency,            // Format number as Currency
    bytes,               // Format number in human readable disk size
    link,                // Format URL as <a> link
    linkTel,             // Format Phone Number as <a> tel: link
    linkMailTo,          // Format email as <a> mailto: link
    icon,                // Format Image URL as an Icon
    iconRounded,         // Format Image URL as a full rounded Icon
    attachment,          // Format File attachment URL as an Attachment
    hidden,              // Format as empty string
    time,                // Format duration in time format
    relativeTime,        // Format Date as Relative Time from now
    relativeTimeFromMs,  // Format time in ms as Relative Time from now
    formatDate,          // Format as Date
    formatNumber,        // Format as Number
} = useFormatters()
```

Many of these formatting functions return rich HTML markup which will need to be rendered using Vue's **v-html** directive:

```html
<span v-html="formatValue(value)"></span>
```

<api-reference component="HtmlFormat"></api-reference>
## HtmlFormat

`HtmlFormat` can be used to render any Serializable object into a human-friendly HTML Format:

### Single Model

```html
<HtmlFormat :value="tracks[0]" />
```
<div class="not-prose max-w-screen-sm">
    <html-format :value="tracks[0]"></html-format>
</div>

### Item Collections

```html
<HtmlFormat :value="tracks" />
```
<div class="not-prose max-w-screen-sm">
    <html-format :value="tracks"></html-format>
</div>

### Nested Complex Types

```html
<HtmlFormat :value="players" />
```
<div class="not-prose prose-table">
<html-format :value="players"></html-format>
</div>

### Nested Complex Types with custom classes

When needed most default classes can be overridden with a custom **classes** function that can inspect the
type, tag, depth, and row index to return a custom class. The TypeScript function shows an example of checking
these different parameters to render a custom HTML resultset:

```html
<HtmlFormat :value="players" :classes="classes" />

<script lang="ts">
function classes(type:'array'|'object', tag:'div'|'table'|'thead'|'th'|'tr'|'td',depth:number,cls:string,index?:number)
{
    if (type === 'array') {
        if (tag === 'th') return cls.replace('text-sm text-gray-500 font-medium',' ') + (depth === 0 
            ? 'text-xs uppercase font-semibold text-indigo-700'
            : 'text-xs font-medium text-gray-500')
        if (tag === 'tr') return depth > 0 || index! % 2 == 0 ? 'bg-white' : 'bg-yellow-50'
        if (tag === 'td' && depth > 0) return 'px-4 py-3 whitespace-nowrap text-xs'
    }
    return cls
}
</script>
```
<div class="not-prose prose-table">
<html-format :value="players" :classes="classes"></html-format>
</div>


# App Metadata
Source: https://razor-press.web-templates.io/vue/use-metadata

The rich server metadata about your APIs that's used to generate your App's DTOs in 
[Multiple Programming Languages](/add-servicestack-reference), power ServiceStack's 
[built-in Auto UIs](/locode/declarative) also power the Metadata driven components in the **@servicestack/vue** component library 
where it can be loaded in your `_Layout.cshtml` using an optimal configuration like:

```html
var dev = HostContext.AppHost.IsDevelopmentEnvironment();
@if (dev) {
    <script>window.Server = @await Html.ApiAsJsonAsync(new MetadataApp())</script>
}

<script type="module">
import { useMetadata } from "@@servicestack/vue"

const { loadMetadata } = useMetadata()
loadMetadata({
    olderThan: window.Server ? null : location.search.includes('clear=metadata') ? 0 : 60 * 60 * 1000 //1hr 
})
</script>
```

Where during development it always embeds the AppMetadata in each page but as this metadata can become quite large for systems with a lot of APIs, the above optimization clears and reloads the AppMetadata after **1 hr** or if the page was explicitly loaded with `?clear=metadata`, 
otherwise it will use a local copy cached in `localStorage` at `/metadata/app.json`, which Apps needing more 
fine-grained cache invalidation strategies can manage themselves.

Once loaded the AppMetadata features can be access with the helper functions in [useMetadata](/vue/use-metadata).

```js
import { useMetadata } from "@servicestack/vue"

const { 
    loadMetadata,      // Load {AppMetadata} if needed 
    setMetadata,       // Explicitly set AppMetadata and save to localStorage
    clearMetadata,     // Delete AppMetadata and remove from localStorage
    metadataApi,       // Reactive accessor to Ref<MetadataTypes>
    typeOf,            // Resolve {MetadataType} for DTO name
    typeOfRef,         // Resolve {MetadataType} by {MetadataTypeName}
    apiOf,             // Resolve Request DTO {MetadataOperationType} by name
    property,          // Resolve {MetadataPropertyType} by Type and Property name
    enumOptions,       // Resolve Enum entries for Enum Type by name
    propertyOptions,   // Resolve allowable entries for property by {MetadataPropertyType}
    createFormLayout,  // Create Form Layout's {InputInfo[]} from {MetadataType}
    typeProperties,    // Return all properties (inc. inherited) for {MetadataType}
    supportsProp,      // Check if a supported HTML Input exists for {MetadataPropertyType}
    Crud,              // Query metadata information about AutoQuery CRUD Types
    getPrimaryKey,     // Resolve PrimaryKey {MetadataPropertyType} for {MetadataType}
    getId,             // Resolve Primary Key value from {MetadataType} and row instance
    createDto,         // Create a Request DTO instance for Request DTO name
    toFormValues,      // Convert Request DTO values to supported HTML Input values
    formValues,        // Convert HTML Input values to supported DTO values
} = useMetadata()
```

For example you can use this to view all C# property names and Type info for the `Contact` C# DTO with:

```html
<HtmlFormat :value="typeOf('Contact').properties.map(({ name, type, namespace }) => ({ name, type, namespace }))" />
```
<div class="not-prose">
<html-format :value="typeOf('Contact').properties.map(({ name, type, namespace }) => ({ name, type, namespace }))"></html-format>
</div>

## Enum Values and Property Options

More usefully this can avoid code maintenance and duplication efforts from maintaining enum values on both server and client forms. 

An example of this is in the [Contacts.mjs](https://github.com/NetCoreTemplates/razor-tailwind/blob/main/MyApp/wwwroot/Pages/Contacts.mjs) 
component which uses the server metadata to populate the **Title** and **Favorite Genre** select options from the `Title` and `FilmGenre` enums:

```html
<div class="grid grid-cols-6 gap-6">
  <div class="col-span-6 sm:col-span-3">
    <SelectInput id="title" v-model="request.title" :options="enumOptions('Title')" />
  </div>
  <div class="col-span-6 sm:col-span-3">
    <TextInput id="name" v-model="request.name" required placeholder="Contact Name" />
  </div>
  <div class="col-span-6 sm:col-span-3">
    <SelectInput id="color" v-model="request.color" :options="colorOptions" />
  </div>
  <div class="col-span-6 sm:col-span-3">
    <SelectInput id="favoriteGenre" v-model="request.favoriteGenre" :options="enumOptions('FilmGenre')" />
  </div>
  <div class="col-span-6 sm:col-span-3">
    <TextInput type="number" id="age" v-model="request.age" />
  </div>
</div>
```

Whilst the `colorOptions` gets its values from the available options on the `CreateContact.Color` property:    

```js
const Edit = {
    //...
    setup(props) {
        const { property, propertyOptions, enumOptions } = useMetadata()
        const colorOptions = propertyOptions(property('CreateContact','Color'))
        return { enumOptions, colorOptions }
        //..
    }
}
```

Which instead of an enum, references the C# Dictionary in:

```csharp
public class CreateContact : IPost, IReturn<CreateContactResponse>
{
    [Input(Type="select", EvalAllowableEntries = "AppData.Colors")]
    public string? Color { get; set; }
    //...
}
```

To return a C# Dictionary of custom colors defined in:

```csharp
public class ConfigureUi : IHostingStartup
{
    public void Configure(IWebHostBuilder builder) => builder
        .ConfigureAppHost(appHost => {
            //Enable referencing AppData.* in #Script expressions
            appHost.ScriptContext.Args[nameof(AppData)] = AppData.Instance;
        });
}

public class AppData
{
    public static readonly AppData Instance = new();
    public Dictionary<string, string> Colors { get; } = new() {
        ["#F0FDF4"] = "Green",
        ["#EFF6FF"] = "Blue",
        ["#FEF2F2"] = "Red",
        ["#ECFEFF"] = "Cyan",
        ["#FDF4FF"] = "Fuchsia",
    };
}
```

## AutoForm Components

See [Auto Form Components](/vue/autoform) docs for examples of easy to use, high productivity `AppMetadata` powered components.

## TypeScript Definition

TypeScript definition of the API surface area and type information for correct usage of `useMetadata()`

```ts
import type { 
    AppMetadata, MetadataType, MetadataPropertyType, MetadataOperationType, InputInfo, KeyValuePair 
} from "./types"


/** Load {AppMetadata} if needed 
 * @param olderThan   - Reload metadata if age exceeds ms
 * @param resolvePath - Override `/metadata/app.json` path use to fetch metadata
 * @param resolve     - Use a custom fetch to resolve AppMetadata
*/
function loadMetadata(args: {
    olderThan?: number;
    resolvePath?: string;
    resolve?: () => Promise<Response>;
}): Promise<AppMetadata>;

/** Check if AppMetadata is valid */
function isValid(metadata: AppMetadata | null | undefined): boolean | undefined;

/** Delete AppMetadata and remove from localStorage */
function setMetadata(metadata: AppMetadata | null | undefined): boolean;

/** Delete AppMetadata and remove from localStorage */
function clearMetadata(): void;


/** Query metadata information about AutoQuery CRUD Types */
const Crud: {
    Create: string;
    Update: string;
    Patch: string;
    Delete: string;
    AnyRead: string[];
    AnyWrite: string[];
    isQuery: (op: MetadataOperationType) => any;
    isCrud: (op: MetadataOperationType) => boolean | undefined;
    isCreate: (op: MetadataOperationType) => boolean | undefined;
    isUpdate: (op: MetadataOperationType) => boolean | undefined;
    isPatch: (op: MetadataOperationType) => boolean | undefined;
    isDelete: (op: MetadataOperationType) => boolean | undefined;
    model: (type?: MetadataType | null) => string | null | undefined;
};

/** Resolve HTML Input type to use for {MetadataPropertyType}  */
function propInputType(prop: MetadataPropertyType): string;

/** Resolve HTML Input type to use for C# Type name */
function inputType(type: string): string;

/** Check if C# Type name is numeric */
function isNumericType(type?: string | null): boolean;

/** Check if C# Type is an Array or List */
function isArrayType(type: string): boolean;

/** Check if a supported HTML Input exists for {MetadataPropertyType} */
function supportsProp(prop?: MetadataPropertyType): boolean;

/** Create a Request DTO instance for Request DTO name */
function createDto(name: string, obj?: any): any;

/** Convert Request DTO values to supported HTML Input values */
function toFormValues(dto: any, metaType?: MetadataType | null): any;

/** Convert HTML Input values to supported DTO values */
function formValues(form: HTMLFormElement, props?: MetadataPropertyType[]): {
    [k: string]: any;
};

/**
 * Resolve {MetadataType} for DTO name
 * @param name        - Find MetadataType by name
 * @param [namespace] - Find MetadataType by name and namespace 
 */
function typeOf(name?: string | null, namespace?: string | null): MetadataType | null;

/** Resolve Request DTO {MetadataOperationType} by name */
function apiOf(name: string): MetadataOperationType | null;

/** Resolve {MetadataType} by {MetadataTypeName} */
function typeOfRef(ref?: {
    name: string;
    namespace?: string;
}): MetadataType | null;

function property(typeName: string, name: string): MetadataPropertyType | null;

/** Resolve Enum entries for Enum Type by name */
function enumOptions(name: string): { [name: string]: string; } | null;

function enumOptionsByType(type?: MetadataType | null): { [name: string]: string; } | null;

/** Resolve Enum entries for Enum Type by MetadataType */
function propertyOptions(prop: MetadataPropertyType): { [name: string]: string; } | null;

/** Convert string dictionary to [{ key:string, value:string }] */
function asKvps(options?: { [k: string]: string; } | null): KeyValuePair<string, string>[] | undefined;

/** Create InputInfo from MetadataPropertyType and custom InputInfo */
function createInput(prop: MetadataPropertyType, input?: InputInfo): InputInfo;

/** Create Form Layout's {InputInfo[]} from {MetadataType} */
function createFormLayout(metaType?: MetadataType | null): InputInfo[];

/** Return all properties (inc. inherited) for {MetadataType} */
function typeProperties(type?: MetadataType | null): MetadataPropertyType[];

/** Check if MetadataOperationType implements interface by name */
function hasInterface(op: MetadataOperationType, cls: string): boolean;

/** Resolve PrimaryKey {MetadataPropertyType} for {MetadataType} */
function getPrimaryKey(type?: MetadataType | null): MetadataPropertyType | null;

/** Resolve Primary Key value from {MetadataType} and row instance  */
function getId(type: MetadataType, row: any): any;
```


# JSON API Client Features
Source: https://razor-press.web-templates.io/vue/use-client

[useClient()](https://github.com/ServiceStack/servicestack-vue/blob/main/src/api.ts) provides managed APIs around the `JsonServiceClient` 
instance registered in Vue App's with:

```js
app.provide('client', client)
```

Which maintains contextual information around your API calls like **loading** and **error** states, used by `@servicestack/vue` components to 
enable its auto validation binding. Other functionality in this provider include:

```js
let { 
    api,            // Send a typed API request and return results in an ApiResult<TResponse>
    apiVoid,        // Send a typed API request and return empty response in a void ApiResult
    apiForm,        // Send a FormData API request and return results in an ApiResult<TResponse>
    apiFormVoid,    // Send a FormData API request and return empty response in a void ApiResult
    loading,        // Maintain loading state whilst API Request is in transit
    error,          // Maintain API Error response in reactive Ref<ResponseStatus>
    setError,       // Set API error state with summary or field validation error
    addFieldError,  // Add field error to API error state
    unRefs          // Returns a dto with all Refs unwrapped
} = useClient()
```

Typically you would need to unwrap `ref` values when calling APIs, i.e:

```js
let client = new JsonServiceClient()
let api = await client.api(new Hello({ name:name.value }))
```

### api

This is unnecessary in useClient `api*` methods which automatically unwraps ref values, allowing for the more pleasant API call:

```js
let api = await client.api(new Hello({ name }))
```

### unRefs

But as DTOs are typed, passing reference values will report a type annotation warning in IDEs with type-checking enabled, 
which can be avoided by explicitly unwrapping DTO ref values with `unRefs`:

```js
let api = await client.api(new Hello(unRefs({ name })))
```

### setError

`setError` can be used to populate client-side validation errors which the 
[SignUp.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/Pages/SignUp.mjs)
component uses to report an invalid submissions when passwords don't match:

```js
const { api, setError } = useClient()
async function onSubmit() {
    if (password.value !== confirmPassword.value) {
        setError({ fieldName:'confirmPassword', message:'Passwords do not match' })
        return
    }
    //...
}
```

## Form Validation

All `@servicestack/vue` Input Components support contextual validation binding that's typically populated from API
[Error Response DTOs](/error-handling) but can also be populated from client-side validation
as done above.

### Explicit Error Handling

This populated `ResponseStatus` DTO can either be manually passed into each component's **status** property as done in [/Todos](https://vue-mjs.web-templates.io/TodoMvc):

```html
<template id="TodoMvc-template">
    <div class="mb-3">
        <text-input :status="store.error" id="text" label="" placeholder="What needs to be done?"
                    v-model="store.newTodo" v-on:keyup.enter.stop="store.addTodo()"></text-input>
    </div>
    <!-- ... -->
</template>
```

Where if you try adding an empty Todo the `CreateTodo` API will fail and populate its `store.error` reactive property with the 
APIs Error Response DTO which the `<TextInput />` component checks for to display any field validation errors matching the
field in `id` adjacent to the HTML Input:

```js
let store = {
    /** @type {Todo[]} */
    todos: [],
    newTodo:'',
    error:null,
    async refreshTodos(errorStatus) {
        this.error = errorStatus
        let api = await client.api(new QueryTodos())
        if (api.succeeded)
            this.todos = api.response.results
    },
    async addTodo() {
        this.todos.push(new Todo({ text:this.newTodo }))
        let api = await client.api(new CreateTodo({ text:this.newTodo }))
        if (api.succeeded)
            this.newTodo = ''
        return this.refreshTodos(api.error)
    },
    //...
}
```

### Implicit Error Handling

More often you'll want to take advantage of the implicit validation support in `useClient()` which makes its state available to child
components, alleviating the need to explicitly pass it in each component as seen in razor-tailwind's 
[Contacts.mjs](https://github.com/NetCoreTemplates/razor-tailwind/blob/main/MyApp/wwwroot/Pages/Contacts.mjs) `Edit` component for its 
[/Contacts](https://vue-mjs.web-templates.io/Contacts) page which doesn't do any manual error handling:

```js
const Edit = {
    template:/*html*/`<SlideOver @done="close" title="Edit Contact">
    <form @submit.prevent="submit">
      <input type="submit" class="hidden">
      <fieldset>
        <ErrorSummary except="title,name,color,filmGenres,age,agree" class="mb-4" />
        <div class="grid grid-cols-6 gap-6">
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="title" v-model="request.title" :options="enumOptions('Title')" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <TextInput id="name" v-model="request.name" required placeholder="Contact Name" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="color" v-model="request.color" :options="colorOptions" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="favoriteGenre" v-model="request.favoriteGenre" :options="enumOptions('FilmGenre')" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <TextInput type="number" id="age" v-model="request.age" />
          </div>
        </div>
      </fieldset>
    </form>
    <template #footer>
      <div class="flex justify-between space-x-3">
        <div><ConfirmDelete @delete="onDelete">Delete</ConfirmDelete></div>
        <div><PrimaryButton @click="submit">Update Contact</PrimaryButton></div>
      </div>
    </template>
  </SlideOver>`,
    props:['contact'],
    emits:['done'],
    setup(props, { emit }) {
        const client = useClient()
        const request = ref(new UpdateContact(props.contact))
        const colorOptions = propertyOptions(getProperty('UpdateContact','Color'))

        async function submit() {
            const api = await client.api(request.value)
            if (api.succeeded) close()
        }
        
        async function onDelete () {
            const api = await client.apiVoid(new DeleteContact({ id:props.id }))
            if (api.succeeded) close()
        }

        const close = () => emit('done')
        
        return { request, enumOptions, colorOptions, submit, onDelete, close }
    }
}
```

This effectively makes form validation binding a transparent detail where all `@servicestack/vue` 
Input Components are able to automatically apply contextual validation errors next to the fields they apply to: 

<div class="my-8">
  <img class="mx-auto max-w-2xl" src="https://servicestack.net/img/pages/scripts/edit-contact-validation.png">
</div>

## Example using apiForm

An alternative method of invoking APIs is to submit a HTML Form Post which can be achieved with Ajax by sending a populated `FormData` 
with `client.apiForm()` as done in vue-mjs's 
[SignUp.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/Pages/SignUp.mjs) for its 
[/signup](https://vue-mjs.web-templates.io/signup) page:

```js
import { ref } from "vue"
import { leftPart, rightPart, toPascalCase } from "@servicestack/client"
import { useClient } from "@servicestack/vue"
import { Register } from "../mjs/dtos.mjs"

export default {
    template:/*html*/`    
    <form @submit.prevent="submit">
      <div class="shadow overflow-hidden sm:rounded-md">
        <ErrorSummary except="displayName,userName,password,confirmPassword,autoLogin" />
        <div class="px-4 py-5 bg-white dark:bg-black space-y-6 sm:p-6">
          <div class="flex flex-col gap-y-4">
            <TextInput id="displayName" help="Your first and last name" v-model="request.displayName" />
            <TextInput id="userName" label="Email" placeholder="Email" help="" v-model="request.userName" />
            <TextInput id="password" type="password" help="6 characters max" v-model="request.password "/>
            <TextInput id="confirmPassword" type="password" v-model="request.confirmPassword" />
            <CheckboxInput id="autoLogin" v-model="request.autoLogin" />
          </div>
        </div>
        <div class="pt-5 px-4 py-3 bg-gray-50 dark:bg-gray-900 text-right sm:px-6">
          <div class="flex justify-end">
            <FormLoading v-if="loading" class="flex-1" />
            <PrimaryButton :disabled="loading" class="ml-3">Sign Up</PrimaryButton>
          </div>
        </div>
      </div>
    </form>`,
    props: { returnUrl:String },
    setup(props) {
        const client = useClient()
        const { setError, loading } = client
        const request = ref(new Register({ autoLogin:true }))

        /** @param email {string} */
        function setUser(email) {
            let first = leftPart(email, '@')
            let last = rightPart(leftPart(email, '.'), '@')
            const dto = request.value
            dto.displayName = toPascalCase(first) + ' ' + toPascalCase(last)
            dto.userName = email
            dto.confirmPassword = dto.password = 'p@55wOrd'
        }
        
        /** @param {Event} e */
        async function submit(e) {
            if (request.value.password !== request.value.confirmPassword) {
                setError({ fieldName: 'confirmPassword', message: 'Passwords do not match' })
                return
            }
            
            // Example using client.apiForm()
            const api = await client.apiForm(new Register(), new FormData(e.target))
            if (api.succeeded) {
                location.href = props.returnUrl || '/signin'
            }
        }
        
        return { loading, request, setUser, submit }
    }
}
```

Which method to use is largely a matter of preference except if your form needs to upload a file in which case using `apiForm` is required.

## AutoForm Components

We can elevate our productivity even further with [Auto Form Components](/vue/autoform) that can automatically generate an
instant API-enabled form with validation binding by just specifying the Request DTO to create the form for, e.g:

```html
<AutoCreateForm type="CreateBooking" formStyle="card" />
```

<div class="mb-4 not-prose">
<auto-create-form type="CreateBooking" form-style="card"></auto-create-form>
</div>

The AutoForm components are powered by your [App Metadata](/vue/use-metadata) which allows creating 
highly customized UIs from [declarative C# attributes](/locode/declarative) whose customizations are
reused across all ServiceStack Auto UIs.

## TypeScript Definition

TypeScript definition of the API surface area and type information for correct usage of `useClient()`

```ts
/** Maintain loading state whilst API Request is in transit */
const loading: Ref<boolean>

/** Maintain API Error in reactive Ref<ResponseStatus> */
const error: Ref<ResponseStatus>

/** Set error state with summary or field validation error */
function setError({ message, errorCode, fieldName, errors }: IResponseStatus);

/** Add field error to API error state */
function addFieldError({ fieldName, message, errorCode }: IResponseError);

/** Send a typed API request and return results in an ApiResult<TResponse> */
async function api<TResponse>(request:IReturn<TResponse> | ApiRequest, args?:any, method?:string);

/** Send a typed API request and return empty response in a void ApiResult */
async function apiVoid(request:IReturnVoid | ApiRequest, args?:any, method?:string);

/** Send a FormData API request and return results in an ApiResult<TResponse> */
async function apiForm<TResponse>(request:IReturn<TResponse> | ApiRequest, body:FormData, args?:any, method?:string);

/** Send a FormData API request and return empty response in a void ApiResult */
async function apiFormVoid(request: IReturnVoid | ApiRequest, body: FormData, args?: any, method?: string);
```


# Auth Features
Source: https://razor-press.web-templates.io/vue/use-auth

Vue.js Apps can access Authenticated Users using [useAuth()](/vue/use-auth)
which can also be populated without the overhead of an Ajax request by embedding the response of the built-in
[Authenticate API](https://vue-mjs.web-templates.io/ui/Authenticate?tab=details) inside `_Layout.cshtml` with:

```html
<script type="module">
import { useAuth } from "@@servicestack/vue"
const { signIn } = useAuth()
signIn(@await Html.ApiAsJsonAsync(new Authenticate()))
</script>
```

Where it enables access to the below [useAuth()](/vue/use-auth) utils for inspecting the 
current authenticated user:  

```js
const { 
    signIn,           // Sign In the currently Authenticated User
    signOut,          // Sign Out currently Authenticated User
    user,             // Access Authenticated User info in a reactive Ref<AuthenticateResponse>
    isAuthenticated,  // Check if the current user is Authenticated in a reactive Ref<boolean>
    hasRole,          // Check if the Authenticated User has a specific role
    hasPermission,    // Check if the Authenticated User has a specific permission
    isAdmin           // Check if the Authenticated User has the Admin role
} = useAuth()
```

An example where this is used is in 
[Bookings.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/Pages/Bookings.mjs)
to control whether the `<AutoEditForm>` component should enable its delete functionality:

```js
export default {
    template/*html*/:`
    <AutoEditForm type="UpdateBooking" :deleteType="canDelete ? 'DeleteBooking' : null" />
    `,
    setup(props) {
        const { hasRole } = useAuth()
        const canDelete = computed(() => hasRole('Manager'))
        return { canDelete }
    }
}
```

## TypeScript Definition

TypeScript definition of the API surface area and type information for correct usage of `useAuth()`

```ts
/** Access the currently Authenticated User info in a reactive Ref<AuthenticateResponse> */
const user: Ref<AuthenticateResponse>

/** Check if the current user is Authenticated in a reactive Ref<boolean> */
const isAuthenticated: Ref<boolean>

/** Sign In the currently Authenticated User */
function signIn(user:AuthenticateResponse): void;

/** Sign Out currently Authenticated User */
function signOut(): void;

/** Check if the Authenticated User has a specific role */
function hasRole(role:string): boolean;

/** Check if the Authenticated User has a specific permission */
function hasPermission(permission:string): boolean;

/** Check if the Authenticated User has the Admin role */
function isAdmin(): boolean;
```


# Formatting Functions and Methods
Source: https://razor-press.web-templates.io/vue/use-formatters

### Using Formatters

Your App and components can also utilize the built-in formatting functions in `useFormatters()`:

```js
import { useFormatters } from '@servicestack/vue'

const {
    Formats,              // Available format methods to use in <PreviewFormat />
    formatValue,          // Format any value or object graph
    currency,             // Format number as Currency
    bytes,                // Format number in human readable disk size
    link,                 // Format URL as <a> link
    linkTel,              // Format Phone Number as <a> tel: link
    linkMailTo,           // Format email as <a> mailto: link
    icon,                 // Format Image URL as an Icon
    iconRounded,          // Format Image URL as a full rounded Icon
    attachment,           // Format File attachment URL as an Attachment
    hidden,               // Format as empty string
    time,                 // Format duration in time format
    relativeTime,         // Format Date as Relative Time from now
    relativeTimeFromMs,   // Format time in ms as Relative Time from now
    relativeTimeFromDate, // Format difference between dates as Relative Time
    formatDate,           // Format as Date
    formatNumber,         // Format as Number

    setDefaultFormats,    // Set default locale, number and Date formats
    setFormatters,        // Register additional formatters for use in <PreviewFormat />
    indentJson,           // Prettify an API JSON Response
    truncate,             // Truncate text that exceeds maxLength with an ellipsis
    apiValueFmt,          // Format an API Response value
} = useFormatters()
```

Many of these formatting functions return rich HTML markup which will need to be rendered using Vue's **v-html** directive:

```html
<span v-html="formatValue(value)"></span>
```

See the [PreviewFormat](/vue/formats) for examples for what each of these format functions render to. 

<api-reference component="setDefaultFormats"></api-reference>
## Set global default formats

Global default formats can be customized with `setDefaultFormats`:

```js
setDefaultFormats({
    locale: null,     // Use Browsers default local
    assumeUtc: true,
    number: null,     // Use locale Number format
    date: {
        method: "Intl.DateTimeFormat",
        options: "{dateStyle:'medium'}"
    },
    maxFieldLength: 150,
    maxNestedFields: 150,
    maxNestedFieldLength: 150,
})
```

<api-reference component="setFormatters"></api-reference>
## Register custom formatters

Use `setFormatters` to register new formatters that you want to use in `[Format("method")]` or 
within `<PreviewFormat/>` components, e.g. you could register a formatter that renders a QR Code image of the content with:

```ts
import { QRCode } from "qrcode-svg"

function qrcode(content) {
    return new QRCode({ content, padding:4, width:256, height:256 }).svg()
}

setFormatters({
    qrcode,
})
```

Where it will be able to be used within format components, e.g:

```html
<PreviewFormat :value="url" :format="{ method:'qrcode' }" />
```

That can also be used to decorate properties in C# DTOs with the [Format Attribute](/locode/formatters), e.g:

```csharp
[Format("qrcode")]
public string Code { get; set; }
```

## Overriding built-in formatters

`setFormatters` can also be to override the built-in formatting functions by registering alternative implementations for:

```ts
setFormatters({
    currency,
    bytes,
    link,
    linkTel,
    linkMailTo,
    icon,
    iconRounded,
    attachment,
    hidden,
    time,
    relativeTime,
    relativeTimeFromMs,
    formatDate,
    formatNumber,
})
```

## TypeScript Definition

TypeScript definition of the API surface area and type information for correct usage of `useFormatters()`

```ts
class Formats {
    static currency: FormatInfo;
    static bytes: FormatInfo;
    static link: FormatInfo;
    static linkTel: FormatInfo;
    static linkMailTo: FormatInfo;
    static icon: FormatInfo;
    static iconRounded: FormatInfo;
    static attachment: FormatInfo;
    static time: FormatInfo;
    static relativeTime: FormatInfo;
    static relativeTimeFromMs: FormatInfo;
    static date: FormatInfo;
    static number: FormatInfo;
    static hidden: FormatInfo;
}

/** Format any value or object graph */
function formatValue(value: any, format?: FormatInfo | null, attrs?: any): any;

/** Format number as Currency */
function currency(val: number, attrs?: any): string;

/** Format number in human readable disk size */
function bytes(val: number, attrs?: any): string;


/** Format URL as <a> link */
function link(href: string, opt?: {
    cls?: string;
    target?: string;
    rel?: string;
}): string;

/** Format email as <a> mailto: link */
function linkMailTo(email: string, opt?: {
    subject?: string;
    body?: string;
    cls?: string;
    target?: string;
    rel?: string;
}): string;

/** Format Phone Number as <a> tel: link */
function linkTel(tel: string, opt?: {
    cls?: string;
    target?: string;
    rel?: string;
}): string;

/** Format Image URL as an Icon */
function icon(url: string, attrs?: any): string;

/** Format Image URL as a full rounded Icon */
function iconRounded(url: string, attrs?: any): string;

/** Format File attachment URL as an Attachment */
function attachment(url: string, attrs?: any): string;

/** Format as empty string */
function hidden(o: any): string;

/** Format duration in time format */
function time(o: any, attrs?: any): string;

/** Format Date as Relative Time from now */
function relativeTime(val: string | Date | number, rtf?: Intl.RelativeTimeFormat): string | undefined;

/** Format difference between dates as Relative Time */
function relativeTimeFromDate(d: Date, from?: Date): string | undefined;

/** Format time in ms as Relative Time from now */
function relativeTimeFromMs(elapsedMs: number, rtf?: Intl.RelativeTimeFormat): string | undefined;

/** Format as Date */
function formatDate(d: Date | string | number, attrs?: any): string;

/** Format as Number */
function formatNumber(n: number, attrs?: any): string;

/** Set default locale, number and Date formats */
function setDefaultFormats(newFormat: DefaultFormats): void;

/** Register additional formatters for use in <PreviewFormat /> */
function setFormatters(formatters: {
    [name: string]: Function;
}): void;

/** Prettify an API JSON Response */
function indentJson(o: any): string;

/** Truncate text that exceeds maxLength with an ellipsis */
function truncate(str: string, maxLength: number): string;

/** Format an API Response value */
function apiValueFmt(o: any, format?: FormatInfo | null, attrs?: any): any;
```


# File Utils
Source: https://razor-press.web-templates.io/vue/use-files

The file utils are utilized by the `<FileInput>` [Input component](/vue/form-inputs) and 
`icon`, `iconRounded` and `attachment` [formatters](/vue/use-formatters) for resolving file SVG Icons 
and MIME Types that Apps can also utilize in `useFiles()`

```js
import { useFiles } from '@servicestack/vue'

const {
    extSvg,           // Resolve SVG XML for file extension
    extSrc,           // Resolve SVG Data URI for file extension
    getExt,           // Resolve File extension from file name or path
    canPreview,       // Check if path or URI is of a supported web image type
    getFileName,      // Resolve file name from /file/path
    getMimeType,      // Resolve the MIME type for a file path name or extension
    formatBytes,      // Format file size in human readable bytes
    filePathUri,      // Resolve the Icon URI to use for file
    encodeSvg,        // Encode SVG XML for usage in Data URIs
    svgToDataUri,     // Convert SVG XML to data:image URL
    fileImageUri,     // Resolve image preview URL for file
    objectUrl,        // Create and track an Object URL for an uploaded file
    flush,            // Release all tracked Object URLs
    inputFiles,       // Resolve file metadata for all uploaded HTML input files
    iconOnError,      // Error handler for broken images to return a fallbackSrc
    iconFallbackSrc,  // Resolve the fallback URL for a broken Image URL
} = useFiles()
```

## TypeScript Definition

TypeScript definition of the API surface area and type information for correct usage of `useFiles()`

```ts
/** Resolve SVG XML for file extension */
function extSvg(ext: string): string | null;

/** Resolve SVG URI for file extension */
function extSrc(ext: string): any;

/** Resolve File extension from file name or path */
function getExt(path?: string | null): string | null;

/** Check if path or URI is of a supported web image type */
function canPreview(path: string): boolean;

/** Resolve file name from /file/path */
function getFileName(path?: string | null): string | null;

/** Resolve the MIME type for a file path name or extension */
function getMimeType(fileNameOrExt: string): string;

/** Format file size in human readable bytes */
function formatBytes(bytes: number, d?: number): string;

/** Resolve the Icon URI to use for file */
function filePathUri(path?: string): string | null;

/** Encode SVG XML for usage in Data URIs */
function encodeSvg(s: string): string;

/** Convert SVG XML to data:image URL */
function svgToDataUri(svg: string): string;

/** Resolve image preview URL for file */
function fileImageUri(file: any | {
    name: string;
}): string | null;

/** Create and track Image URL for an uploaded file */
function objectUrl(file: Blob | MediaSource): string;

/** Release all tracked Object URLs */
function flush(): void;

/** Resolve file metadata for all uploaded HTML file input files */
function inputFiles(input: HTMLInputElement): {
    fileName: string;
    contentLength: number;
    filePath: string | null;
}[] | null;

/** Error handler for broken images to return a fallbackSrc */
function iconOnError(img: HTMLImageElement, fallbackSrc?: string): void;

/** Resolve the fallback URL for a broken Image URL */
function iconFallbackSrc(src: string, fallbackSrc?: string): string | null;
```


# Vue Tailwind Global Configuration
Source: https://razor-press.web-templates.io/vue/use-config

## Manage Global Configuration

`useConfig` is used to maintain global configuration that's used throughout the Vue Component Library.

```ts
import { useConfig } from "@servicestack/vue"

const {
    config,                   // Resolve configuration in a reactive Ref<UiConfig>
    setConfig,                // Set global configuration
    assetsPathResolver,       // Resolve Absolute URL to use for relative paths
    fallbackPathResolver,     // Resolve fallback URL to use if primary URL fails
    autoQueryGridDefaults,    // Resolve AutoQueryGrid default configuration
    setAutoQueryGridDefaults, // Set AutoQueryGrid default configuration
} = useConfig()
```

The asset and fallback URL resolvers are useful when hosting assets on a separate CDN from the hosted website.

### Default configuration

```js
setConfig({
    redirectSignIn:       '/signin',
    assetsPathResolver:   src => src,
    fallbackPathResolver: src => src,
})
```

## AutoQueryGrid Defaults

Use `setAutoQueryGridDefaults` to change the default configuration for all [AutoQueryGrid](/vue/autoquerygrid) components:

```ts
const { setAutoQueryGridDefaults } = useConfig()

setAutoQueryGridDefaults({
    deny: [],
    hide: [],
    toolbarButtonClass: undefined,
    tableStyle: "stripedRows",
    take: 25,
    maxFieldLength: 150,
})
```

TypeScript Definitions for available AutoQueryGridDefaults:

```ts
type AutoQueryGridDefaults = {
    deny?:GridAllowOptions[]
    hide?:GridShowOptions[]
    toolbarButtonClass?: string
    tableStyle?: TableStyleOptions
    take?:number
    maxFieldLength?: number
}

export type GridAllowOptions = "filtering" | "queryString" | "queryFilters"
export type GridShowOptions = "toolbar" | "preferences" | "pagingNav" | "pagingInfo" | "downloadCsv" 
    | "refresh" | "copyApiUrl" | "resetPreferences" | "filtersView" | "newItem"
```

## TypeScript Definition

TypeScript definition of the API surface area and type information for correct usage of `useConfig()`

```ts
interface UiConfig {
    redirectSignIn?: string
    assetsPathResolver?: (src:string) => string
    fallbackPathResolver?: (src:string) => string
}

/** Resolve configuration in a reactive Ref<UiConfig> */
const config:ComputedRef<UiConfig>

/** Set global configuration */
function setConfig(config: UiConfig): void;

/** Resolve Absolute URL to use for relative paths */
function assetsPathResolver(src?: string): string | undefined;

/** Resolve fallback URL to use if primary URL fails */
function fallbackPathResolver(src?: string): string | undefined;
```


# General Utils
Source: https://razor-press.web-templates.io/vue/use-utils

General utils used by Vue Components you may also find useful in your Apps:

```js
import { useUtils } from "@servicestack/vue"

const {
    dateInputFormat,  // Format Date into required input[type=date] format
    timeInputFormat,  // Format TimeSpan or Date into required input[type=time] format
    setRef,           // Double set reactive Ref<T> to force triggering updates
    unRefs,           // Returns a dto with all Refs unwrapped
    transition,       // Update reactive `transition` class based on Tailwind animation transition rule-set
    focusNextElement, // Set focus to the next element inside a HTML Form
    getTypeName,      // Resolve Request DTO name from a Request DTO instance
    htmlTag,          // HTML Tag builder
    htmlAttrs,        // Convert object dictionary into encoded HTML attributes
    linkAttrs,        // Convert HTML Anchor attributes into encoded HTML attributes
    toAppUrl,         // Resolve Absolute URL from relative path
    isPrimitive,      // Check if value is a scalar type
    isComplexType,    // Check if value is a non-scalar type
} = useUtils()
```

## TypeScript Definition

TypeScript definition of the API surface area and type information for correct usage of `useUtils()`

```ts
/** Format Date into required input[type=date] format */
declare function dateInputFormat(d: Date): string;

/** Format TimeSpan or Date into required input[type=time] format */
declare function timeInputFormat(s?: string | number | Date | null): string;

/** Double set reactive Ref<T> to force triggering updates */
declare function setRef($ref: Ref<any>, value: any): void;

/** Returns a dto with all Refs unwrapped */
declare function unRefs(o: any): any;

/** Update reactive `transition` class based on Tailwind animation transition rule-set */
declare function transition(rule: TransitionRules, transition: Ref<string>, show: boolean): void;

/** Set focus to the next element inside a HTML Form */
declare function focusNextElement(): void;

/** Resolve Request DTO name from a Request DTO instance */
declare function getTypeName(dto: any): any;

/** HTML Tag builder */
declare function htmlTag(tag: string, child?: string, attrs?: any): string;

/** Convert object dictionary into encoded HTML attributes */
declare function htmlAttrs(attrs: any): string;

/** Convert HTML Anchor attributes into encoded HTML attributes */
declare function linkAttrs(attrs: {
    href: string;
    cls?: string;
    target?: string;
    rel?: string;
}): {
    target: string;
    rel: string;
    class: string;
} & {
    href: string;
    cls?: string | undefined;
    target?: string | undefined;
    rel?: string | undefined;
};

/** Resolve Absolute URL from relative path */
declare function toAppUrl(url: string): string | undefined;

/** Check if value is a scalar type */
declare function isPrimitive(value: any): boolean;

/** Check if value is a non-scalar type */
declare function isComplexType(value: any): boolean;
```


